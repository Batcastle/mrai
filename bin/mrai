#!/bin/bash
# -*- coding: utf-8 -*-
#
#  mrai
#  
#  Copyright 2019 Thomas Castleman <contact@draugeros.org>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#first off, mrai should NOT be run as root. So, check for that and kill mrai if it is running as root, before it can do any damage
#we want todo this first, in case there are any bugs in the code below
version="1.1.0-beta3"
if [[ "$EUID" == "0" ]]; then
    /bin/echo -e "\nPlease do not run mrai with root privleges. This will cause file system issues with GitHub installations.\n" && exit 2
fi
#pre-config
#check if mrai is already running
/bin/pidof -x -o "$$" "mrai" > /dev/null
if [ "$?" == "0" ] && [ "$1" != "--version" ] && [ "$1" != "-v" ] && [ "$(/bin/echo "$1" | /bin/grep -q '-S')" != 0 ] && [ "$(/bin/echo "$1" | /bin/grep -q '--search')" != 0 ] && [ "$(/bin/echo "$1" | /bin/grep -q '--find')" != 0 ] && [ "$(/bin/echo "$1" | /bin/grep -q '--query')" != 0 ]; then
    /bin/echo -e "\nmrai is already running.\nFor security and stability reasons, please refrain from using mrai until this process has exited.\n"
	exit 2
fi
cache="/etc/mrai"
gitautocache="/etc/mrai/gitauto"
gitmancache="/etc/mrai/gitman"
user=$(/usr/bin/whoami)
if [ "$1" == "--version" ] || [ "$1" == "-v" ]; then
	/bin/echo -e "\n$version\n"
	exit 0
elif [ "$1" == "--fix-config" ]; then
	/bin/echo -e "\nAttempting to correct package configuration. Please wait . . . \n"
	/usr/bin/pkexec /usr/bin/dpkg --configure -a
	exit "$?"
elif [ "$1" == "--add-repo" ]; then
	if [ "$2" == "-a" ] || [ "$2" == "--apt" ]; then
		if $(/bin/echo "$3" | /bin/grep -q "ppa:"); then
			/usr/bin/pkexec /usr/bin/add-apt-repository "$3"
		else
			/usr/bin/pkexec /usr/bin/add-apt-repository ppa:"$3"
		fi
		exit $?
	elif [ "$2" == "-f" ] || [ "$2" == "--flat" ]; then
		if $(/bin/echo "$3" | /bin/grep -q "http://") || $(/bin/echo "$3" | /bin/grep -q "https://"); then
			read -p "What would you like to name this repo?: " name
			/usr/bin/flatpak remote-add --if-not-exists "$name" "$3"
		else
			read -p "What would you like to name this repo?: " name
			/usr/bin/flatpak remote-add --if-not-exists "$name" http://"$3"
		fi
		exit $?
	else
		/bin/echo -e "\nERROR: No package manager indicated\n"
		exit 2
	fi
elif [ "$1" == "--edit-sources" ] || [ "$1" == "--edit-repos" ] || [ "$1" == "--edit-apt-repos" ]; then
	/bin/echo -e "\nTo enable an apt repo, remove the \"# \" (including the space) from the beginning of the line.\nTo disable a repo, just add the \"# \" back to the beginning of the line.\n\nLines beginning with \"deb-src\" are for source code.\n"
	if [ -d /etc/apt/sources.list.d ]; then
		sld=$(/bin/ls /etc/apt/sources.list.d)
		if [ "$sld" == "" ] || [ "$sld" == " " ]; then
			/usr/bin/pkexec $cache/bin/edit-apt-sources.sh "/etc/apt/sources.list"
		else
			/bin/echo -e "\nYour sources.list.d directroy has config files in it as well.\n"
			/bin/echo "0 /etc/apt/sources.list"
			int=1
			for each in $sld; do
				/bin/echo "$int /etc/apt/sources.list.d/$each"
				int=$((int+1))
			done
			int=$((int-1))
			read -p "Give the number of the file you would like to edit: [0-$int]: " choice
			int=1
			for each in $sld; do
				if [ "$choice" == "0" ]; then
					file="/etc/apt/sources.list"
					break
				fi
				if [ "$int" == "$choice" ]; then
					if [ "$choice" == "0" ]; then
						file="/etc/apt/sources.list"
					else
						file="/etc/apt/sources.list.d/$each"
					fi
					break
				else
					int=$((int+1))
				fi
			done
			{
				/usr/bin/pkexec $cache/bin/edit-apt-sources.sh "$file"
			} && {
				exit 0
			} || {
				exit $?
			}
		fi
	else
		/usr/bin/pkexec $cache/bin/edit-apt-sources.sh "/etc/apt/sources.list"
		exit $?
	fi
fi
h="mrai Package Manager: the Multiple Repo App Installer

-c, --clean		Delete old *.deb files, old config files, and old Github files

--find			Find the package the provides a given command

-i,--install		Install an app, if none of the below options are given, check in the following order:
			apt, snap, flatpak, Github manual method, Github automatic method


	-a, ---apt		Install just from apt. In which case, usage will be:

						mrai -ia {apt-package-name}


	-g, --git,		Install just from Github, In which case, usage will be:
	--gm, --ga		
						mrai -ig {/github-username/github-repo-name (or Github URL)}
				
					Under this flag you can also use -m or -a to manually indicate whether to install from GitHub manually or
					automaticlly. Please only use the automatic method if the Repo uses a Makefile to install it's software on your
					system.


	-s, --snap		Install just from snapd, In which case, usage will be:

						mrai -is {snap-name}

	
	-f, --flat		Install as Flatpak, In which case, usage will be:

						mrai -if {flatpak-name}


-h, --help		Display this help dialogue and exit.


-r, --remove		Uninstall an app. {name-installed-under} refers to the name given to refer to the GitHub installation,
--uninstall		the name of the apt package, the name of the snap, or the name of the flatpak, depending on how it was installed


-S, --search,		Search for an app. For GitHub based apps, this only works if they are installed. To find apps to install from GitHub,
--query			please vist https://www.github.com

	
	-a, --apt		Search for an app through apt


	-s, --snap		Search for an app through snap


	-f, --flat		Search for an app through flatpak


	--ga			Search for an app that was installed using GitHub Automatic Method


	--gm			Search for an app that was installed using GitHub Manual Method


	--git			Search for an app installed from GitHub, regardless of method


	-v, --verbose		Give more information about the queried package


-u, --update,		Update your software. This may or may not work for packages installed from Github.
--upgrade

	-a, --apt		Update from only apt


	-f, --flat		Update from only Flatpak


	-g, --git		Update from only Github

	
	-s, --snap		Update only installed snaps


-v, --version		Print Current Version and exit


--fix-config		Essentially this runs 'sudo dpkg --configure -a', to fix package management issues


--add-repo		Add a repository, MUST BE FOLLOWED BY ONE OF THE FOLLOWING OPTIONS:


	-a, --apt		adds a new PPA

	
	-f, --flat		adds a new Flatpak Remote


-l, --list		List installed apps, pass a package name after this flag to search for an installed app


	-a, --apt	Filter installed apps to ones installed with apt


	-f, --flat	Filter installed apps to ones installed with Flatpak


	-s, --snap	Filter installed apps to ones installed with Snap


	--ga		Filter installed apps to ones installed using GitHub Automatic Method


	--gm		Filter installed apps to ones installed using GitHub Manual Method


	--git		Filter installed apps to ones installed from GitHub, regardless of method


--edit-sources,		Edit enabled apt repos by editing /etc/apt/sources.list or one of the files
--edit-repos,		in /etc/apt/sources.list.d
--edit-apt-repos,"
if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then
	/bin/echo -e "\n$h\n"
	exit 0
fi
#check for apt-fast, snapd, and flatpak and update the flags
if $(/usr/bin/dpkg -l | /bin/grep -q "ii  apt-fast"); then
	if [[ ! -f "$cache"/apt-fast.flag ]]; then
		/bin/echo "" >> "$cache"/apt-fast.flag
	fi
else
	if [is_aptfast_installed]; then
		/bin/rm "$cache"/apt-fast.flag
	fi
fi
if $(/usr/bin/dpkg -l | /bin/grep -q "ii  snapd"); then
	if [[ ! -f "$cache"/snapd.flag ]]; then
		/bin/echo "" >> "$cache"/snapd.flag
	fi
else
	if [is_snapd_installed]; then
		/bin/rm "$cache"/snapd.flag
	fi
fi
if $(/usr/bin/dpkg -l | /bin/grep -q "ii  flatpak"); then
	if [[ ! -f "$cache"/flatpak.flag ]]; then
		/bin/echo "" >> "$cache"/flatpak.flag
	fi
else
	if [is_flatpak_installed]; then
		/bin/rm "$cache"/flatpak.flag
	fi
fi
#Start Defining Functions

#Force update snaps
snapupdate () {
	{
		/bin/bash /bin/snapupdate
	} || {
		/bin/echo -e "\nWe're sorry snapupdate failed with exit code $?. Please fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#Install software from apt
aptinstall () {
	for each in $pass; do
		if $(/usr/bin/dpkg -l "$each" 2>/dev/null | /bin/grep -q "ii  $each"); then
			continue
		else
			new="$new $each"
		fi
	done
	for each in $pass; do
		if $(/bin/echo "$new" | /bin/grep -q "$each"); then
			verify="$verify 1"
		else
			continue
		fi
	done
	/bin/echo "$verify" | /bin/grep -q "1"
	check=$?
	if [ "$check" != "0" ]; then
		/bin/echo -e "\nAll passed packages are already installed.\n"
		exit 1
	else
			pass="$new"
	fi
	if [ "$check" == "0" ]; then
		if is_aptfast_installed; then
			({
				#Install software using apt-fast, if available based on the apt-fast.flag
				#use /usr/bin/pkexec to gain root privleges in order to install software
				if [ "$a" == "1" ]; then
					/usr/bin/pkexec /usr/sbin/apt-fast -y install $pass
				else
					/usr/bin/pkexec /usr/sbin/apt-fast install $pass
				fi
			} && {
			#update flags if snapd or flatpak get installed
				if [ "$pass" == "flatpak" ]; then
					/bin/echo "" >> "$cache"/flatpak.flag
					/usr/bin/flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
				elif [ "$pass" == "snapd" ]; then
					/bin/echo "" >> "$cache"/snapd.flag
				fi
			}) || return 2
		else
			({
				#install software using apt, due to the unavailability of apt-fast
				if [ "$a" == "1" ]; then
					/usr/bin/pkexec /usr/bin/apt -y install $pass
				else
					/usr/bin/pkexec /usr/bin/apt install $pass
				fi
			} && {
			#update flags if snapd, flatpak, or apt-fast get installed
				if [ "$pass" == "apt-fast" ]; then
					/bin/echo "" >> "$cache"/apt-fast.flag
				elif [ "$pass" == "snapd" ]; then
					/bin/echo "" >> "$cache"/snapd.flag
				elif [ "$pass" == "flatpak" ]; then
					/bin/echo "" >> "$cache"/flatpak.flag
					/usr/bin/flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
				fi
			}) || return 2
		fi
	else
		/bin/echo -e "\nThis package is already installed.\n"
		if [ "$1" == "-i" ] || [ "$1" == "--install" ]; then
			return 1
		else
			exit 1
		fi
	fi
}

#install software, using a more automatic method, from GitHub
gitautoinst () {
	{
		/usr/bin/pkexec "$cache"/bin/gitautoinst.sh "$HOME" "$user" "$pass"
	} || {
		/bin/echo -e "\nWe're sorry. gitautoinst has failed with code $?. Please fill out an issue report\non our GitHub at https://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

flatinstall () {
	#check that flatpak.flag is in place
	if is_flatpak_installed; then
		loop=1
		while [ "$loop" == "1" ]; do
			#search for the desired package, to ensure it exists
			q=$(/usr/bin/flatpak search "$pass")
			r=$(/bin/echo "$q" | /usr/bin/awk '{print $1}')
			if [ "$r" == "No matches found" ]; then
				#see if there are any flatpak repos added, this is a common
				#issue with people new to flatpak. Checking and adding it for them
				#then rechecking just saves them the pain
				list=$(/usr/bin/flatpak remotes)
				if $(/bin/echo "$list" | /bin/grep -q 'flathub'); then
					#there are repos added, so the flatpak is at least not in these repos
					#or just straight up does not exist
					/bin/echo -e "\nNo installation candidates found.\n"
					exit 1
				else
					#no repos where found. Add Flathub and try again.
					/usr/bin/flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
					continue
				fi
			#check to see if it has one of three known flatpack domains. More domains will be added in the future
			elif $(/bin/echo "$r" | /bin/grep -q "org.") || $(/bin/echo "$r" | /bin/grep -q "com.") || $(/bin/echo "$r" | /bin/grep -q "ws.") || $(/bin/echo "$r" | /bin/grep -q "net.") ||  $(/bin/echo "$r" | /bin/grep -q "io.") ||  $(/bin/echo "$r" | /bin/grep -q "work.") || $(/bin/echo "$r" | /bin/grep -q "nl.") || $(/bin/echo "$r" | /bin/grep -q "im.") || $(/bin/echo "$r" | /bin/grep -q "fr.") ||  $(/bin/echo "$r" | /bin/grep -q "cc.") ||  $(/bin/echo "$r" | /bin/grep -q "info.") ||  $(/bin/echo "$r" | /bin/grep -q "in.") ||  $(/bin/echo "$r" | /bin/grep -q "eu.") ||  $(/bin/echo "$r" | /bin/grep -q "edu.") ||  $(/bin/echo "$r" | /bin/grep -q "de.") ||  $(/bin/echo "$r" | /bin/grep -q "cx.") ||  $(/bin/echo "$r" | /bin/grep -q "us."); then
				set -- "$r"
				test="$2"
				if [ -z "$test" ]; then	
					#try installing the desired flatpak from each repo
					list=$(/usr/bin/flatpak remotes)
					list1=$(/bin/echo "$list" | /usr/bin/awk '{print $1}')
					/bin/echo -e "\nAttempting to install $r as a Flatpak. Please wait . . . \n"
					for entry in $list1; do
						{
							if [ "$a" == "1" ]; then
								/usr/bin/flatpak install -y "$entry" "$r"
							else
								/usr/bin/flatpak install "$entry" "$r"
							fi
							break
						} || { 
							/bin/echo -e "\nFlatpak installation from $entry failed.\n"
						}
					done
					loop="0"
				else
					#for mutliple installation canditdates, ask which the user wishes to install.
					/bin/echo -e "\nERROR: Multiple Installation Candidates Detected.\n"
					/bin/echo -e "Which package would you like to install?\n$r\n"
					read -p "Please copy-paste the name of the package here (Type \"exit\", \"break\", or \"end\" to exit): " int
					#check if the user wants out. If they do, let them out
					if [ "$int" == "exit" ] || [ "$int" == "break" ] || [ "$int" == "end" ]; then
						exit 2
					fi
					#go through the install process for the designated flatpak package
					list=$(/usr/bin/flatpak remotes)
					list1=$(/bin/echo "$list" | /usr/bin/awk '{print $1}')
					/bin/echo -e "\nAttempting to install $r as a Flatpak. Please wait . . . \n"
					for entry in $list1; do
						{
							if [ "$a" == "1" ]; then
								/usr/bin/flatpak install -y "$entry" "$int"
							else
								/usr/bin/flatpak install "$entry" "$int"
							fi
							break
						} || { 
							/bin/echo -e "\nFlatpak installation from $entry failed.\n"
						}
					done
					loop="0"
				fi
			else
				#Okay. If we end up having to run the code down here, we have an issue. 
				#It's minor, but an issue.
				#This should only run if $r is set to something that EITHER
				#	A. Isn't "No Matches Found"
				#		OR
				#	B. Does not contain the name of a flatpak
				#In fact, lets print that.
				/bin/echo -e "\nSomething happened...and it wasn't good.\nIt appears Flatpak returned something other then \"No Matches Found\" or something with the name of at least on Flatpak in it.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
				#There. Bit long, but it was needed. 
				#Alright. Lets end this puppy.
				loop="0"
				return 1
			fi
		done
	else
		#Check to see if they called EXPLICITLY to install using flatpak, cause if they did they may not know they don't have it
		if [ "$1" == "-if" ] || [ "$2" == "--flat" ]; then
			#Tell them they don't have flatpak
			#Also, if the user wants to mrai to use flatpak they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			/bin/echo -e "\nSorry. Package 'flatpak' is not installed. Please run {mrai -ia flatpak} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi		
}

#install snap apps
snapinstall () {
	#check for the snapd.flag file
	if is_snapd_installed; then
		#check for the app we want
		for each in $pass; do
			list=$(/usr/bin/snap list)
			if $(/bin/echo "$list" | /bin/grep -q "$each"); then
				continue
			else
				new="$new $each"
			fi
		done
		for each in $pass; do
			if $(/bin/echo "$new" | /bin/grep -q "$each"); then
				verify="$verify 1"
			else
				continue
			fi
		done
		/bin/echo "$verify" | /bin/grep -q "1"
		check=$?
		if [ "$check" != "0" ]; then
			/bin/echo -e "\nAll passed packages are already installed.\n"
			exit 1
		else
			pass="$new"
		fi
		if [ "$check" == "0" ]; then
			#try to install the snap normally. This is prefered over classic snaps
			#for security reasons due to it's comperably lacking amount of access to the user's system
			#as compared to classic snaps
			/usr/bin/snap install $pass || read -p "Standard Snap Installation Failed. Attempt Classic Snap Installation? [y/N]: " ans
			if [ ! -z $ans ]; then
				#check to see if they are cool with the classic snaps, and if so install it. Or at least try to.
				if [ "$ans" == "Y" ] || [ "$ans" == "y" ]; then
					/usr/bin/snap install $pass --classic || /bin/echo -e "\nSnap installation failed.\n"
				else
					return 2
				fi
			fi
		else
			return 1
		fi
	else
		#Check to see if they called EXPLICITLY to install using snapd, cause if they did they may not know they don't have it
		if [ "$z" == "-s" ] || [ "$z" == "--snap" ]; then
			#Tell them they don't have snapd
			#Also, if the user wants to mrai to use snapd they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			/bin/echo -e "\nSorry. Package 'snapd' is not installed. Please run {mrai -ia snapd} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi
}

#install from GitHub using manual method
gitmaninstall () {
	cd $HOME
	/bin/mkdir .mrai
	cd .mrai
	#check the passed URL's syntax
	if $(/bin/echo "$pass" | /bin/grep -q 'https://github.com/') || $(/bin/echo "$pass" | /bin/grep -q 'http://github.com/'); then
        	git clone "$pass"
	elif $(/bin/echo "$pass" | /bin/grep -q 'github.com/'); then
	        git clone https://$pass
	else 
	        git clone https://github.com/$pass
	fi
	pass1=$(/bin/echo $pass | /bin/sed 's/.*\///')
	cd $pass1
	/bin/echo -e "\n$(/bin/ls)\n"
	#get the file the user needs to run to install their software
	read -p "Which of the above files would you like to try to run in order to install $z? (Case-Sensitive) : " run
	#check if the indicated file needs to run as root. Cause we can do that . . . indirectly.
	read -p "Should this file be run with root privleges? [y/N]: " ans
	ans=$(/bin/echo "$ans" | /usr/bin/awk '{print tolower($0)}')
	if [ "$ans" == "y" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		/bin/chmod +x $(/bin/pwd)/$run
		#run as root
		/usr/bin/pkexec $(/bin/pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		/bin/mkdir "$gitmancache"/"$pass1" && /bin/cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		/bin/echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		/bin/echo "RUN_AS_ROOT=yes" >> "$gitmancache"/man.flag
		/bin/echo "RUN=$run" >> "$gitmancache"/man.flag
	elif [ "$ans" == "n" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		/bin/chmod +x $(/bin/pwd)/$run
		#run it
		exec $(/bin/pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		/bin/mkdir "$gitmancache"/"$pass1" && /bin/cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		/bin/echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		/bin/echo "RUN_AS_ROOT=no" >> "$gitmancache"/man.flag
		/bin/echo "RUN=$run" >> "$gitmancache"/man.flag
	elif [ "$ans" == "cancel" ] || [ "$ans" == "exit" ] || [ "$ans" == "end" ]; then
		/bin/echo -e "\nAborting . . .\n"
	else
		#this will probably happen to someone at some point.
		#WE DO NOT RUN ANYTHING, I REPEAT, ANYTHING, AS ROOT BY DEFAULT
		#THIS PRESENTS A SECURITY RISK AND SHOULD NEVER BE DONE
		/bin/echo -e "\nInput not recognized. Running without root privileges\n"
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		/bin/chmod +x $(/bin/pwd)/$run
		#run it
		exec $(/bin/pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		/bin/mkdir "$gitmancache"/"$pass1" && /bin/cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		/bin/echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		/bin/echo "RUN_AS_ROOT=null" >> "$gitmancache"/man.flag
		/bin/echo "RUN=$run" >> "$gitmancache"/man.flag
	fi
}

#remove apt packages
aptremove () {
	{
		if [ "$a" == "1" ]; then
			/usr/bin/pkexec "$cache"/bin/aptremove.sh 1 "$pass" "$user"
		else
			/usr/bin/pkexec "$cache"/bin/aptremove.sh "$pass" "$user"
		fi
	} || {
		/bin/echo -e "\nWe're sorry. aptremove.sh has failed with exit code $?. Please fill out an issue report at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit $?
	}
}

#remove apps installed through GitHub
gitremove () {
	#check if the passed app is a git-auto app
	if $(gitautolist | /bin/grep -q "$pass"); then
		#cd into the appropriate directory
		cd "$gitautocache"/"$pass"
		#check for a Makefile
		if $(/bin/echo "$(/bin/ls)" | /bin/grep -q "Makefile"); then
			#try make uninstall and make remove, cause they sometimes work
			{
				/usr/bin/make uninstall || /usr/bin/make remove
			} && {
				#something went right, so remove the files that mrai held on to so that it could
				#delete or update the app later
				cd ..
				/bin/rm -rf "$pass"
				/bin/echo -e "\n$pass has been removed.\n"
				exit 0
			}
		else
			/bin/echo -e "\nWe're sorry. No Makefile could be found. Therefore, mrai cannot uninstall $z\n"
		fi
	#check if the passed app is a git-man app if not a git-auto
	elif $(gitmanlist | /bin/grep -q "$pass"); then
		#cd into the proper directory
		cd "$gitmancache"/"$pass"
		#read the *.flag file and parse the info needed from it
		flag=$(/bin/ls | /bin/grep "man.flag")
		root=$(/bin/cat $flag | /bin/grep "RUN_AS_ROOT=")
		run=$(/bin/cat $flag | /bin/grep "RUN=")
		run=$(/bin/echo $run | /bin/sed 's/RUN=//')
		#check if the designated file needs to be run as root
		if [ "$root" == "RUN_AS_ROOT=yes" ]; then
			/bin/echo -e "\nAttempting to uninstall. Please wait . . .\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				/bin/echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					/bin/echo -e "\nAll other options on the install script have failed. Please look online for documentation on how to remove this app.\nWe are sorry for any inconvenience.\n" && exit 2
				fi
				#Sleep so the user can read what we just /bin/echoed out
				/bin/sleep 3s
				#run the file with the designated option as root
				(( /usr/bin/pkexec $(/bin/pwd)/"$run" "$opt" ) && ( sent=1 )) || ( ((num+=1)) )
			done
		elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
			/bin/echo -e "\nAttempting to uninstall. Please wait . . .\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				/bin/echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					/bin/echo -e "\nAll other options on the install script have failed. Please look online for documentation on how to remove this app.\nWe are sorry for any inconvenience.\n" && exit 2
				fi
				#Sleep so the user can read what we just /bin/echoed out
				/bin/sleep 3s
				#run the file with the designated option, BUT NOT AS ROOT
				(( exec $(/bin/pwd)/"$run" "$opt" ) && ( sent=1 )) || ( ((num+=1)) )
			done
		else
			#Okay, if we get down here, something fucked up.
			#The contents of ANY *.flag file made by one of the two git install functions (see gitmaninstall and gitautoinst)
			#should contain both an "ADDRESS" field and a "RUN_AS_ROOT" feild. RUN_AS_ROOT can only be a "yes", "no", or "null"
			#if RUN_AS_ROOT is set to anything else, this will be displayed
			/bin/echo -e "\nWe're sorry. The function gitremove has encountered an error. Please fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n" && exit 2
		fi
	else
		/bin/echo -e "\nWe're sorry. The function gitremove in /bin/mrai has encountered an error. Please contact the devs for help.\n" && exit 2
	fi		
}

#remove flatpak packages
flatremove () {
	{
		#flatpak doesn't need root, so not called as such
		if [ "$a" == "1" ]; then
			/usr/bin/flatpak remove -y "$pass"
		else
			/usr/bin/flatpak remove "$pass"
		fi
	} || {
		/bin/echo -e "\nWe're sorry. Function flatremove has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#remove snap packages
snapremove () {
	{
		#snap elevates itself to root, so not gonna bother calling it as root. That way, more of it runs without root access,
		#allowing it to be more secure, while also saving space in this file
		/usr/bin/snap remove "$pass"
	} || {
		/bin/echo -e "\nWe're sorry. Function snapremove has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#update apps installed through GitHub
gitupdate () {
	#check first to see if gitupdate got passed an empty or null string. Cause why bother if nothing to use?
	if [ "$pass" == " " ] || [ "$pass" == "" ]; then
		/bin/echo -e "\nNo Apps installed from GitHub through mrai.\n"
		return 0
	fi
	cd "$cache"
	#do this for each app installed from GitHub
	for each in $pass; do
		pass1="$each"
		if $( /bin/ls | /bin/grep -q '$z'); then
			cd "$pass1"
			#read the *.flag file and parse it for info
			flag=$(/bin/ls | /bin/grep ".flag")
			root=$(/bin/cat $flag | /bin/grep "RUN_AS_ROOT=")
			add=$(/bin/cat $flag | /bin/grep "ADDRESS=")
			call=$(/bin/echo $add | /bin/sed 's/ADDRESS=//')
			run=$(/bin/cat $flag | /bin/grep "RUN=")
			run=$(/bin/echo $run | /bin/sed 's/RUN=//')
			back=$(/bin/pwd)
			del=$(/usr/bin/find -type f -name "*.deb")
			cd $HOME/.mrai/"$pass1"
			#"Call home" and get the new software
			if $(/bin/echo "$call" | /bin/grep -q 'https://github.com/') || $(/bin/echo "$call" | /bin/grep -q 'http://github.com/'); then
				git clone "$call"
			elif $(/bin/echo "$call" | /bin/grep -q 'github.com/'); then
	        		git clone https://$call
			else
				git clone https://github.com/$call
			fi
			#check if $run is set, if it isn't, we are using the Makefile method of doing things
			if [[ -z $run ]]; then
				#some Makefiles have an update function. Others you have to reinstall
				( /usr/bin/make update ) || ( /usr/bin/make && /usr/bin/make install ) || /bin/echo -e "\nMakefile update method failed.\n"
				#clean up
				/bin/rm "$back"/"$del"
				deb=$(/usr/bin/find -type f -name "*.deb")
				/bin/cp "$deb" "$gitautocache"/"$pass1"
			else
				#check if we need to run this as root
				if [ "$root" == "RUN_AS_ROOT=yes" ]; then
					#run the file as root
					/usr/bin/pkexec $(/bin/pwd)/$run $opt
				elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
					#run the designated file, but NOT AS ROOT
					exec $(/bin/pwd)/$run $opt
					#if the *.flag file's RUN_AS_ROOT is set to null, ask if the user wants to reset it to either yes or no
					#none of the *.flag files should have a RUN_AS_ROOT set as null, but it is possible to happen do to the 
					#complexity of programming it to re-ask if the passed string doesn't match a certain set of criteria
					if [ "$root" == "RUN_AS_ROOT=null" ]; then
						#fix the null value
						read -p "Should this be run as root in the future? [y/N]: " ans
						if [ "$ans" == "y" ] || [ "$ans" == "Y" ]; then
							/bin/sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=yes/g' $flag
						elif [ "$ans" == "n" ] || [ "$ans" == "N" ]; then
							/bin/sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=no/g' $flag
						else
							/bin/echo -e "\nAnswer not recognized. We will ask again next time.\n"
						fi
					fi
				fi
			fi
		else
			#gotta have some sorta error handling XD
			/bin/echo -e "\nThis app does not appear to be installed from GitHub.\n"
		fi
	done
}

#update flatpaks
flatupdate () {
	#check if the flatpak.flag file is there, cause why use flatpak if flatpak isn't even installed?
	if is_flatpak_installed; then
		#update flatpak packages
		/bin/echo -e "\nUpdating Flatpaks. Please wait . . . \n"
		/usr/bin/flatpak update 2>/dev/null || /bin/echo -e "\nFlatpak has had an error. Please try updating again later with 'mrai -uf'.\n"
		/bin/echo ""
	elif [ "$1" == "-uf" ] || [ "$2" == "--flat" ]; then
		/bin/echo -e "\nSorry. Package 'flatpak' is not installed. Please run 'mrai -ia flatpak' to install it.\n"
		exit 2
	fi
}

#figure out how a specific app is installed
checkinstalltype () {
	#check how a given app is installed by checking the list of installed apps in each
	#then /bin/grepping over that list and looking for the app
	type=""
	if $(/usr/bin/dpkg -l | /bin/grep -q "ii  $pass"); then
		type=0
	fi
	if is_snapd_installed && $(/usr/bin/snap list | /bin/grep -q "$pass"); then
		type="$type 1"
	fi
	if is_flatpak_installed && $(/usr/bin/flatpak list  | /bin/grep -q "$pass"); then
		type="$type 2"
	fi
	if $(/bin/ls --group-directories-first "$gitautocache" | /bin/grep -q "$pass"); then
		type="$type 3"
	fi
	if $(/bin/ls --group-directories-first "$gitmancache" | /bin/grep -q "$pass"); then
		type="$type 4"
	fi
	if [ "$type" == "" ]; then
		type=5
	fi
}

#list apps installed from GitHub that where installed using automatic method
gitautolist () {
	{
		/bin/ls --group-directories-first $gitautocache
	} || {
		/bin/echo -e "\nWe're sorry. Function gitautolist has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#list apps installed from GitHub that where installed using manual method
gitmanlist () {
	{
		/bin/ls --group-directories-first $gitmancache
	} || {
		/bin/echo -e "\nWe're sorry. Function gitmanlist has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#clean up
clean () {
	{
		if [ "$a" == "1" ]; then
			/usr/bin/pkexec "$cache"/bin/clean.sh -y $user
		else
			/usr/bin/pkexec "$cache"/bin/clean.sh $user
		fi
	} || {
		/bin/echo -e "\nWe're sorry. clean.sh has failed with exit code $?. Please fill out an issue report at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit $?
	}
}

#Functions to check if suggested packages are installed

#check for snapd
is_snapd_installed () {
	if [ -f "$cache"/snapd.flag ]; then
		return 0
	else
		return 1
	fi
}

#check for apt-fast
is_aptfast_installed () {
	if [ -f "$cache"/apt-fast.flag ]; then
		return 0
	else
		return 1
	fi
}
#check for flatpak
is_flatpak_installed () {
	if [ -f "$cache"/flatpak.flag ]; then
		return 0
	else
		return 1
	fi
}

#Welp. There's all the functions Lets define some variables
y="$2"
z="$3"
w="$4"
#new flag detection system
#set variables so that they can iterated over without throwing errors
u=""
S=""
i=""
r=""
c=""
a=0
#install flag
if [ "$1" == "--install" ]; then
	test=2
	while [ "$test" != "1" ]; do
		evaluator=${!test}
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			test=2
		fi
		if [ "$evaluator" == "--apt" ]; then
			i="a"
		elif [ "$evaluator" == "--snap" ]; then
			i="s"
		elif [ "$evaluator" == "--flat" ]; then
			i="f"
		elif [ "$evaluator" == "--gm" ]; then
			i="gm"
		elif [ "$evaluator" == "--ga" ]; then
			i="ga"
		elif [ "$evaluator" == "--git" ]; then
			i="gb"
		elif [ "$evaluator" == "-y" ] || [ "$evaluator" == "--assume-yes" ]; then
			a=1
		else
			i=${i:-"l"}
			pass="$evaluator"
		fi
		(( test+=1 ))
	done
#search flag
elif [ "$1" == "--search" ] || [ "$1" == "--query" ]; then
	test=2
	while [ "$test" != "1" ]; do
		evaluator="${!test}"
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			test=2
		fi
		if [ "$evaluator" == "--apt" ]; then
			S="$S p"
		elif [ "$evaluator" == "--snap" ]; then
			S="$S s"
		elif [ "$evaluator" == "--flat" ]; then
			S="$S f"
		elif [ "$evaluator" == "--gm" ]; then
			S="$S m"
		elif [ "$evaluator" == "--ga" ]; then
			S="$S o"
		elif [ "$evaluator" == "--git" ]; then
			S="$S l"
		elif [ "$evaluator" == "--verbose" ]; then
			VERBOSE=1
		else
			S=${S:-"a"}
			pass="$evaluator"
		fi
		(( test+=1 ))
	done
#update flag
elif [ "$1" == "--update" ] || [ "$1" == "--upgrade" ]; then
	test=2
	while [ "$test" != "1" ]; do
		evaluator="${!test}"
		if [ "$evaluator" == "--apt" ]; then
			u="$u a"
		elif [ "$evaluator" == "--snap" ]; then
			u="$u s"
		elif [ "$evaluator" == "--flat" ]; then
			u="$u f"
		elif [ "$evaluator" == "--git" ]; then
			u="$u g"
		elif [ "$evaluator" == "-y" ] || [ "$evaluator" == "--assume-yes" ]; then
			a=1
		else
			u=${u:-"a s f g"}
		fi
		(( test+=1 ))
	done
#uninstall flag
elif [ "$1" == "--remove" ] || [ "$1" == "--uninstall" ]; then
	r=1
	pass="$2"
	test=2
	while [ "$test" != "1" ]; do
		evaluator="${!test}"
		if [ "$evaluator" == "--assume-yes" ] || [ "$evaluator" == "-y" ]; then
			a=1
		fi
		(( test+=1 ))
	done
#clean flag
elif [ "$1" == "--clean" ]; then
	c=1
	test=2
	while [ "$test" != "1" ]; do
		evaluator="${!test}"
		if [ "$evaluator" == "--assume-yes" ] || [ "$evaluator" == "-y" ]; then
			a=1
		fi
		(( test+=1 ))
	done
elif [ "$1" == "--list" ]; then
	LIST=1
	test="2"
	while [ "$test" != "1" ]; do
		evaluator="${!test}"
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			test=2
		fi
		if [ "$evaluator" == "--apt" ]; then
			L="$L p"
		elif [ "$evaluator" == "--snap" ]; then
			L="$L s"
		elif [ "$evaluator" == "--flat" ]; then
			L="$L f"
		elif [ "$evaluator" == "--gm" ]; then
			L="$L gm"
		elif [ "$evaluator" == "--ga" ]; then
			L="$L ga"
		elif [ "$evaluator" == "--git" ]; then
			L="$L gb"
		else
			L=${L:-"a"}
			pass="$evaluator"
		fi
		(( test+=1 ))
	done
elif [ "$1" == "--find" ]; then
	FIND=1
	look="$2"
fi
if [ -z "$i" ] && [ -z "$r" ] && [ -z "$c" ] && [ -z "$S" ] && [ -z "$u" ] && [ -z "$LIST" ] && [ -z "$FIND" ]; then
	#compound flag managment system
	while getopts 'uSircl' flag; do
		case "${flag}" in
			#update flag
			u) 
				if [ "$1" == "-u" ] || [ "$1" == "-uy" ] || [ "$1" == "-yu" ]; then
					u="a s f g"
					if [ "$1" == "-uy" ] || [ "$1" == "-yu" ]; then
						a=1
					fi
					break
				fi
				while getopts 'asfgy' flag; do
					case "${flag}" in
						a) u="$u a" ;;
						s) u="$u s" ;;
						f) u="$u f" ;;
						g) u="$u g" ;;
						y) a=1 ;;
						*) 
							if [ "$1" == "-u" ]; then
								u="a s f g"
							else
								/bin/echo -e "\nSorry. This option is not recognized.\n"
								exit 1
							fi
							;;
					esac
				done ;;
			#search flag
			S) 
				if [ "$1" == "-S" ] || [ "$1" == "-Sv" ]; then
					S="a"
					pass="$2"
					if [ "$1" == "-Sv" ]; then
						VERBOSE="1"
					fi
					break
				fi		
				while getopts 'asfgv' flag; do
					case "${flag}" in
						a) S="$S p" ;;
						s) S="$S s" ;;
						f) S="$S f" ;;
						g) 
							if [ "$1" == "-Sg" ]; then
								S="$S l"
								break
							fi
							while getopts 'ma' flag; do
								case "${flag}" in
									m) S="$S m" ;;
									a) S="$S o" ;;
									*) S="$S l" ;;
								esac
							done ;;
						v) VERBOSE="1" ;;
						*) 
							if [ "$1" == "-S" ]; then
								S="a"
							else
								/bin/echo -e "\nSorry. This option is not recognized.\n"
							exit 1
							fi ;;
					esac
				done
				x=2
				while [ "$x" != 1 ]; do
					if [ "$x" == "2" ]; then
						if [ "${!x}" == "" ]; then
							(( x+=1 ))
							continue
						else
							pass="${!x}"
							(( x+=1 ))
							break
						fi
					else
						if [ "${!x}" == "" ]; then
							x=1
							break
						else
							pass="${!x}"
							(( x+=1 ))
							break
						fi
					fi
				done ;;
			#install flag
			i) 
				if [ "$1" == "-i" ] || [ "$1" == "-iy" ] || [ "$1" == "-yi" ]; then
					i="l"
					pass="$2"
					if [ "$1" == "-iy" ] || [ "$1" == "-yi" ]; then
						a=1
					fi
					break
				fi
				while getopts 'asfgy' flag; do
					case "${flag}" in
						a) i="a" ;;
						s) i="s" ;;
						f) i="f" ;;
						y) a=1 ;;
						g) 
							if [ "$1" == "-ig" ]; then
								i="$i gb"
								break
							fi
							while getopts 'ma' flag; do
								case "${flag}" in
									m) i="gm" ;;
									a) i="ga" ;;
									*) i="gb" ;;
								esac
							done ;;
						*) 
							if [ "$1" == "-i" ]; then
								i="l"
							else
								/bin/echo -e "\nSorry. This option is not recognized.\n"
								exit 1
							fi ;;
					esac
				done ;;
			#remove flag
			r) 
				if [ "$1" == "-r" ] || [ "$1" == "-ry" ] || [ "$1" == "-yr" ]; then
					r=1
					if [ "$1" == "-ry" ]; then
						a=1
					fi
				fi;;
			#clean flag
			c)
				if [ "$1" == "-c" ] || [ "$1" == "-cy" ] || [ "$1" == "-yc"; then
					c=1
					if [ "$1" == "-cy" ] || [ "$1" == "-yc" ]; then
						a=1
					fi
				fi;;
			l) LIST=1
				while getopts 'asfg' flag; do
					case "${flag}" in
						a) L="p" ;;
						s) L="s" ;;
						f) L="f" ;;
						g) 
							if [ "$1" == "-lg" ]; then
								L="$L gb"
								break
							fi
							while getopts 'ma' flag; do
								case "${flag}" in
									m) L="gm" ;;
									a) L="ga" ;;
									*) L="gb" ;;
								esac
							done ;;
					esac
				done
				L=${L:-"a"};;
			#all else
			*)
				/bin/echo -e "\nError: Option not recognized.\n\n$h\n"
				exit 2;;
		esac
	done
fi
#check to make sure SOMETHING is set
if [ -z "$i" ] && [ -z "$r" ] && [ -z "$c" ] && [ -z "$S" ] && [ -z "$u" ] && [ -z "$LIST" ] && [ -z "$FIND" ]; then
	/bin/echo -e "\nError in main function: Case failed with 0 commands reported. Please file a bug report at https://github.com/drauger-os-development/mrai/issues\n"
	exit 2
else
	#check for the install flags
	if [[ ! -z "$i" ]]; then
		#check for apt sub-flag
		if [ "$i" == "a" ]; then
			#set $pass to $y that way aptinstall can use it
			pass="$y"
			pass=$(/bin/echo "$pass" | /bin/sed 's/,/ /')
			( aptinstall && exit 0 ) || exit 2
		#git sub-flag
		elif $(/bin/echo "$i" | /bin/grep -q "g"); then
			#manual sub-flag
			if $(/bin/echo "$i" | /bin/grep -q "gm"); then
				pass="$y"
				( gitmaninstall && exit 0 ) || exit 2
			#auto sub-flag
			elif $(/bin/echo "$i" | /bin/grep -q "ga"); then
				pass="$y"
				( gitautoinst && exit 0 ) || exit 2
			elif $(/bin/echo "$i" | /bin/grep -q "gb"); then
				pass="$y"
				( gitautoinst && exit 0 ) || ( gitmaninstall && exit 1 ) || exit 2
			fi
		#snap sub-flag
		elif [ "$i" == "s" ]; then
			pass="$2"
			pass=$(/bin/echo "$pass" | /bin/sed 's/,/ /g')
			( snapinstall && exit 0 ) || exit 2
		#flatpak sub-flag
		elif [ "$i" == "f" ]; then
			pass="$y"
			( flatinstall && exit 0 ) || exit 2
		#none of the sub-flags where passed, so try ALL install methods until one works
		elif [ "$i" == "l" ]; then
			/bin/echo -e "\nAttempting to install\n"	
			{
				aptinstall
			} || {
				snapinstall
			} || {
				flatinstall
			} || {
				pass="$y"
				gitautoinst
			} || {
				gitmaninstall
			} || {
				/bin/echo -e "\nWe're sorry. All installation methods failed.\nPlease make sure that you have the Github username,\nrepo name, and package name spelled correctly\n"
				exit 2
			}
		else
			/bin/echo -e "\nAn error has occured in main function. Please file a bug report at https://github.com/drauger-os-development/mrai/issues\n"
			exit 2
		fi
	#remove / uninstall flag
	elif [[ ! -z "$r" ]] && [ "$r" == "1" ]; then
		#check the way a certain app is installed so it can be properly removed
		pass="$y"		
		checkinstalltype
		if $(/bin/echo "$type" | /bin/grep -q " "); then
			if [ "$type" == " 1" ]; then
				snapremove
			elif [ "$type" == " 2" ]; then
				flatremove
			elif [ "$type" == " 3" ] || [ "$type" == " 4" ]; then
				gitremove
			else
				#make a case, set a variable containing text equal to methods an app is installed by
				for each in $type; do
					case "$each" in
						0) show="apt"; input=" 1 for apt"; check="1" ;;
						1) show="$show snap"; input="$input 2 for snap"; check="$check 2" ;;
						2) show="$show flatpak"; input="$input 3 for flatpak"; check="$check 3" ;;
						3) show="$show Github_Automatic" ;;
						4) show="$show Github_Manual" ;;
						*) /bin/echo "There is an unrecognized value in \$type variable. Error in checkinstalltype"; exit 2 ;;
					esac
				done
				if $(/bin/echo "$show" | /bin/grep -q "Github"); then
					input="$input 4 for Github Manual OR Automatic"
					check="$check 4"
				fi
				/bin/echo -e "\nThere are mutliple apps which fit the package name passed installer.\n\nThese are installed through: $show\n\nFrom which package manager would you like to uninstall?"
				read -p "$input. Select ONE: " ans
				while [ ! -z $ans ]; do
					if [ "$ans" == "1" ] && $(/bin/echo "$check" | /bin/grep -q "1"); then
						aptremove
						exit 0
					elif [ "$ans" == "2" ] && $(/bin/echo "$check" | /bin/grep -q "2"); then
						snapremove
						exit 0
					elif [ "$ans" == "3" ] && $(/bin/echo "$check" | /bin/grep -q "3"); then
						flatremove
						exit 0
					elif [ "$ans" == "4" ] && $(/bin/echo "$check" | /bin/grep -q "4"); then
						gitremove
						exit 0
					elif [ "$ans" == "exit" ] || [ "$ans" == "cancel" ] || [ "$ans" == "EXIT" ] || [ "$ans" == "CANCEL" ]; then
						/bin/echo -e "\nExiting . . .\n"
						exit 0
					else
						/bin/echo -e "\nUnrecognized Input passed. Please try again.\n"
						/bin/echo -e "\nThere are mutliple apps which fit the package name passed installer.\n\nThese are installed through: $show\n\nFrom which package manager would you like to uninstall?"
						read -p "$input. Select ONE: " ans
					fi
				done
			fi
		elif [ "$type" == "0" ]; then
			aptremove
		elif [ "$type" == "5" ]; then
			/bin/echo -e "\nAccording to all our databases, this app is not installed.\n\nApps with similar package names:\n\n"
			show=$(/usr/bin/dpkg -l | /bin/grep '^ii' | /bin/grep "$pass")
			/bin/echo -e "Apt Packages:\n\n"
			if [ "$show" == " " ] || [ "$show" == "" ]; then
				/bin/echo -e "No Apt Packages with similar names installed.\n"
			else
				/bin/echo -e "$show\n"
			fi
			if is_snapd_installed; then
				show=$(/usr/bin/snap list | /bin/grep "$pass")
				/bin/echo "Snaps:\n\n"
				if [ "$show" == " " ] || [ "$show" == "" ]; then
					/bin/echo -e "No Snaps with similar names installed.\n"
				else
					/bin/echo -e "$show\n"
				fi
			fi
			if is_flatpak_installed; then
				show=$(/usr/bin/flatpak list | /bin/grep "$pass")
				/bin/echo "Flatpaks:\n\n"
				if [ "$show" == " " ] || [ "$show" == "" ]; then
					/bin/echo -e "No Flatpaks with similar names installed.\n"
				else
					/bin/echo -e "$show\n"
				fi
			fi
			exit 1
		else
			#if we get something other than a value from 1 and 5 set to $type, we have a SERIOUS issue. Please submit a bug report in this instance
			/bin/echo -e "\nmrai has encountered an error in function {checkinstalltype}.\nPlease submit a bug report at https://github.com/drauger-os-development/mrai/issues.\n"
			exit 2
		fi
	#update flag
	elif [[ ! -z "$u" ]]; then
		for x in $u; do
			if [ "$x" == "f" ]; then
				flatupdate
			elif [ "$x" == "g" ]; then
				if [[ ! -z "$2" ]]; then 
					pass="$2"
				else
					t=$(gitautolist)
					r=$(gitmanlist)
					pass="$t $r"
				fi
				gitupdate
			elif [[ "$x" == "a" ]]; then
				if [ "$a" == "0" ]; then
					if $(/bin/echo "$u" | /bin/grep -q "s"); then
						/usr/bin/pkexec /bin/aptupdate -s
					else
						/usr/bin/pkexec /bin/aptupdate
					fi
				elif [ "$a" == "1" ]; then
					if $(/bin/echo "$u" | /bin/grep -q "s"); then
						/usr/bin/pkexec /bin/aptupdate -sy
					else
						/usr/bin/pkexec /bin/aptupdate -y
					fi
				else
					/bin/echo -e "\n We're sorry. An error has occured in the implementation of the assume-yes flag.\nPlease report this bug to\nhttps://github.com/drauger-os-development/mrai/issues\n"
					exit 2
				fi
			elif [[ "$x" == "s" ]]; then
				if $(/bin/echo "$u" | /bin/grep -q "a"); then
					continue
				else
					/bin/snapupdate
				fi
			else
				continue
			fi
		done
	#search flag
	elif [[ ! -z "$S" ]]; then
		if [ "$VERBOSE" != "1" ]; then
			#apt sub-flag, only search from apt
			if $(/bin/echo "$S" | /bin/grep -q "p"); then
				/usr/bin/apt search "$pass"
			fi
			#flatpak sub-flag, only search from flatpak
			if $(/bin/echo "$S" | /bin/grep -q "f"); then
				if is_flatpak_installed; then
					/usr/bin/flatpak search "$pass"
				else
					/bin/echo -e "\nFlatpak is not installed. Please run \"mrai -ia flatpak\" to install it.\n"
				fi
			fi
			#snap sub-flag, only search from snap
			if $(/bin/echo "$S" | /bin/grep -q "s"); then
				if is_snapd_installed; then
					/usr/bin/snap search "$pass"
				else
					/bin/echo -e "\nSnapd is not installed. Please run \"mrai -ia snapd\" to install it.\n"
				fi
			fi
			#Manual GitHub sub-flag, only search apps installed using manual method from GitHub
			if $(/bin/echo "$S" | /bin/grep -q "m"); then
				list=$(gitmanlist | /bin/grep "$pass")
				/bin/echo -e "\nInstalled through Manual Method:\n$list\n"
			fi
			#Automatic GitHub sub-flag, only search apps installed using automatic method from GitHub
			if $(/bin/echo "$S" | /bin/grep -q "o"); then
				list=$(gitautolist | /bin/grep "$pass")
				/bin/echo -e "\nInstalled through Automatic Method:\n$list\n"
			fi
			#generel GitHub sub-flag, only search apps installed from GitHub, regardless of method
			if $(/bin/echo "$S" | /bin/grep -q "l"); then
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
				/bin/echo -e "\n$list\n"
			fi
		elif [ "$VERBOSE" == "1" ]; then
			#apt sub-flag, only search from apt
			if $(/bin/echo "$S" | /bin/grep -q "p"); then
				/usr/bin/apt show "$pass"
			fi
			#flatpak sub-flag, only search from flatpak
			if $(/bin/echo "$S" | /bin/grep -q "f"); then
				if is_flatpak_installed; then
					/bin/echo -e "\nFlatpak does not support verbose search mode. Using normal search.\n"
					/usr/bin/flatpak search "$pass"
				else
					/bin/echo -e "\nFlatpak is not installed. Please run \"mrai -ia flatpak\" to install it.\n"
				fi
			fi
			#snap sub-flag, only search from snap
			if $(/bin/echo "$S" | /bin/grep -q "s"); then
				if is_snapd_installed; then
					/usr/bin/snap info "$pass"
				else
					/bin/echo -e "\nSnapd is not installed. Please run \"mrai -ia snapd\" to install it.\n"
				fi
			fi
			#Manual GitHub sub-flag, only search apps installed using manual method from GitHub
			if $(/bin/echo "$S" | /bin/grep -q "m"); then
				/bin/echo -e "\nGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .\n"
				list=$(gitmanlist | /bin/grep "$pass")
				/bin/echo -e "\nInstalled through Manual Method:\n$list\n"
			fi
			#Automatic GitHub sub-flag, only search apps installed using automatic method from GitHub
			if $(/bin/echo "$S" | /bin/grep -q "o"); then
				/bin/echo -e "\nGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .\n"
				list=$(gitautolist | /bin/grep "$pass")
				/bin/echo -e "\nInstalled through Automatic Method:\n$list\n"
			fi
			#generel GitHub sub-flag, only search apps installed from GitHub, regardless of method
			if $(/bin/echo "$S" | /bin/grep -q "l"); then
				/bin/echo -e "\nGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .\n"
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
			fi
		fi
		#search EVERYTHING		
		if [ "$S" == "a" ]; then
			if [ "$VERBOSE" != "1" ]; then
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				/bin/echo -e "\nApt packages:\n"
				/usr/bin/apt search "$pass"
				if is_flatpak_installed; then
					/bin/echo -e "\nFlatpak Packages:\n"
					/usr/bin/flatpak search "$pass"
				fi
				if is_snapd_installed; then
					/bin/echo -e "\nSnap Packages:\n"
					/usr/bin/snap search "$pass"
				fi
				list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
				/bin/echo -e "\nInstalled GitHub Apps:\n"
				if [ "$list" == " " ]; then
					/bin/echo -e "No matching GitHub Apps Installed.\n"
				else
					/bin/echo "$list"
				fi
			elif [ "$VERBOSE" == "1" ]; then
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				/bin/echo -e "\nApt packages:\n"
				/usr/bin/apt show "$pass"
				if is_flatpak_installed; then
					/bin/echo -e "\nFlatpak Packages:\n"
					/bin/echo -e "\nFlatpak does not support verbose search mode. Using normal search.\n"
					/usr/bin/flatpak search "$pass"
				fi
				if is_snapd_installed; then
					/bin/echo -e "\nSnap Packages:\n"
					/usr/bin/snap info "$pass"
				fi
				/bin/echo -e "\nGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .\n"
				list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
				/bin/echo -e "\nInstalled GitHub Apps:\n"
				if [ "$list" == " " ]; then
					/bin/echo -e "No matching GitHub Apps Installed.\n"
				else
					/bin/echo "$list"
				fi
			fi
		fi
	#clean flag
	elif [[ ! -z "$c" ]]; then
		clean
	#List flag
	elif [[ "$LIST" == "1" ]]; then
		if [[ ! -z "$2" ]]; then
			if $(/bin/echo "$L" | /bin/grep -q 'p'); then
				/bin/echo -e "\nApt:\n"
				/usr/bin/dpkg -l | /bin/grep '^ii' | /binb/grep "$2"
				/bin/echo ""
			fi
			if $(/bin/echo "$L" | /bin/grep -q 's'); then
				if is_snapd_installed; then
					/bin/echo -e "\nSnaps:\n"
					/usr/bin/snap list "$2"
					/bin/echo ""
				else
					/bin/echo -e "\nWe're sorry. Snapd is not available. Install it with \"mrai -ia snapd\"\n"
				fi
			fi
			if $(/bin/echo "$L" | /bin/grep -q 'f'); then
				if is_flatpak_installed; then
					/bin/echo -e "\nFlatpaks:\n"
					/usr/bin/flatpak list -a | /bin/grep "$2"
					/bin/echo ""
				else
					/bin/echo -e "\nWe're sorry. Flatpak is not available. Install it with \"mrai -ia flatpak\"\n"
				fi
			fi
			if $(/bin/echo "$L" | /bin/grep -q 'gm'); then
				list1=$(gitmanlist | /bin/grep "$2")
				/bin/echo -e "\nInstalled GitHub Apps:\nInstalled through Manual Method:\n$list1\n"
			fi
			if $(/bin/echo "$L" | /bin/grep -q 'ga'); then
				list2=$(gitautolist | /bin/grep "$2")
				/bin/echo -e "\nInstalled GitHub Apps:\nInstalled through Automatic Method:\n$list2\n"
			fi
			if $(/bin/echo "$L" | /bin/grep -q 'gb') && [ ! $(/bin/echo "$L" | /bin/grep -q 'ga') ] && [ ! $(/bin/echo "$L" | /bin/grep -q 'gm') ]; then
				list1=$(gitmanlist | /bin/grep "$2")
				list2=$(gitautolist | /bin/grep "$2")
				/bin/echo -e "\nInstalled GitHub Apps:\nInstalled through Manual Method:\n$list1\n\nInstalled through Automatic Method:\n\n$list2\n\n"
			elif $(/bin/echo "$L" | /bin/grep -q 'gb'); then
				if $(/bin/echo "$L" | /bin/grep -q 'ga') || $(/bin/echo "$L" | /bin/grep -q 'gm'); then
					/bin/echo -e "\nWe're sorry. You already specified either the manual only, or automatic only flags.\nPlease do not use the manual only, automatic only, or unspecified flags in conjunction\n"
				fi
			fi
		else
			/bin/echo -e "\nApt:\n"
			/usr/bin/dpkg -l | /bin/grep '^ii' | /bin/grep "$2"
			if is_snapd_installed; then
				/bin/echo -e "\nSnaps:\n"
				/usr/bin/snap list
			fi
			if is_flatpak_installed; then
				/bin/echo -e "\nFlatpaks:\n"
				/usr/bin/flatpak list -a
			fi
			list1=$(gitmanlist)
			list2=$(gitautolist)
			list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
			/bin/echo -e "\nInstalled GitHub Apps:\n"
			if [ "$list" == "Installed through Manual Method: Installed through Automatic Method:" ]; then
				/bin/echo -e "No GitHub Apps Installed.\n"
			else
				/bin/echo "$list"
			fi
		fi
	elif [ "$FIND" == "1" ]; then
		command_path=$(/usr/bin/dpkg -S $(/usr/bin/which "$look") 2>/dev/null)
		if [ -z "$command_path" ]; then
			/bin/echo -e "\nError: No package providing specificed command.\n"
		else
			command_path=$(/bin/echo "$command_path" | /bin/sed 's/:/ /g' | /usr/bin/awk '{print $1}')
			/bin/echo -e "\nPackage Providing Command \"$look\": $command_path\n"
		fi
	#no recognized flags passed
	else
		/bin/echo -e "\n$h\n"
	fi
fi
