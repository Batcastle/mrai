#!/bin/bash
# -*- coding: utf-8 -*-
#
#  mrai
#  
#  Copyright 2019 Thomas Castleman <contact@draugeros.org>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#first off, mrai should NOT be run as root. So, check for that and kill mrai if it is running as root, before it can do any damage
#we want todo this first, in case there are any bugs in the code below
version="1.3.7-beta5"
R='\033[0;31m'
G='\033[0;32m'
Y='\033[1;33m'
NC='\033[0m'
if [[ "$EUID" == "0" ]]; then
    builtin echo -e "\n$R \bPlease do not run mrai with root privleges. This will cause file system issues with GitHub installations.$NC\n" && exit 2
fi
#pre-config
#check if mrai is already running
test=$(/bin/pidof -x -o "$$" "mrai" 1>/dev/null 2>&1)
if [ "$test" == "0" ] && [ "$1" != "--version" ] && [ "$1" != "-v" ] && [ "$(builtin echo "$1" | /bin/grep -q '-S')" != 0 ] && [ "$(builtin echo "$1" | /bin/grep -q '--search')" != 0 ] && [ "$(builtin echo "$1" | /bin/grep -q '--find')" != 0 ] && [ "$(builtin echo "$1" | /bin/grep -q '--query')" != 0 ]; then
    builtin echo -e "\n$R \bmrai is already running.\nFor security and stability reasons, please refrain from using mrai until this process has exited.$NC\n"
	exit 2
fi
cache="/etc/mrai"
scripts="/usr/share/mrai"
gitautocache="/etc/mrai/gitauto"
gitmancache="/etc/mrai/gitman"
called_as="$0"
user=$(/usr/bin/whoami)
if [ "$1" == "--version" ] || [ "$1" == "-v" ]; then
	builtin echo -e "\n$version\n"
	exit 0
elif [ "$1" == "--fix-config" ]; then
	builtin echo -e "\n$G \bAttempting to correct package configuration. Please wait . . . \n"
	/usr/bin/pkexec /usr/bin/dpkg --configure -a || error_report "$?" "--fix-config failed. Most likely due to faulty package configurations."
	exit "$?"
elif [ "$1" == "--add-repo" ]; then
	if [ "$2" == "-a" ] || [ "$2" == "--apt" ]; then
		if $(builtin echo "$3" | /bin/grep -q "ppa:"); then
			/usr/bin/pkexec /usr/bin/add-apt-repository "$3"
		else
			/usr/bin/pkexec /usr/bin/add-apt-repository ppa:"$3"
		fi
		exit $?
	elif [ "$2" == "-f" ] || [ "$2" == "--flat" ]; then
		if $(builtin echo "$3" | /bin/grep -q "http://") || $(builtin echo "$3" | /bin/grep -q "https://"); then
			read -rp "What would you like to name this repo?: " name
			/usr/bin/flatpak remote-add --if-not-exists "$name" "$3"
		else
			read -rp "What would you like to name this repo?: " name
			/usr/bin/flatpak remote-add --if-not-exists "$name" http://"$3"
		fi
		exit $?
	else
		builtin echo -e "\n$R \bERROR:$NC No package manager indicated\n"
		error_report "2" "User Error: Attempted to add repository without specifying package manager"
	fi
elif [ "$1" == "--edit-sources" ] || [ "$1" == "--edit-repos" ] || [ "$1" == "--edit-apt-repos" ]; then
	builtin echo -e "\nTo enable an apt repo, remove the \"# \" (including the space) from the beginning of the line.\nTo disable a repo, just add the \"# \" back to the beginning of the line.\n\nLines beginning with \"deb-src\" are for source code.\n"
	if [ -d /etc/apt/sources.list.d ]; then
		sld=$(/bin/ls /etc/apt/sources.list.d)
		if [ "$sld" == "" ] || [ "$sld" == " " ]; then
			/usr/bin/pkexec "$scripts/edit-apt-sources" "/etc/apt/sources.list"
		else
			builtin echo -e "\nYour sources.list.d directroy has config files in it as well.\n"
			builtin echo "0 /etc/apt/sources.list"
			int=1
			for each in $sld; do
				builtin echo -e "$int\t/etc/apt/sources.list.d/$each"
				int=$((int+1))
			done
			int=$((int-1))
			check=true
			while $check; do
				read -rp "Give the number of the file you would like to edit: [0-$int]: " choice
				re='^[0-9]+$'
				if ! [[ $choice =~ $re ]]; then
					builtin echo -e "\n$R \bERROR:$NC Not an integer between 0 and $int. Please try again.\n"
				elif [[ $choice -ge 0 ]] && [[ $choice -le $int ]]; then
					check=false
				else
					builtin echo -e "\n$R \bERROR:$NC Not within designated range. Please try again.\n"
				fi
			done
			int=1
			for each in $sld; do
				if [ "$choice" == "0" ]; then
					file="/etc/apt/sources.list"
					break
				fi
				if [ "$int" == "$choice" ]; then
					if [ "$choice" == "0" ]; then
						file="/etc/apt/sources.list"
					else
						file="/etc/apt/sources.list.d/$each"
					fi
					break
				else
					int=$((int+1))
				fi
			done
			/usr/bin/pkexec "$scripts/edit-apt-sources" "$file"
			exit $?
		fi
	else
		/usr/bin/pkexec "$scripts/edit-apt-sources" "/etc/apt/sources.list"
		exit $?
	fi
fi
h="mrai Package Manager: the Multiple Repo App Installer

-c, --clean		Delete old *.deb files, old config files, and old Github files

--find			Find the package the provides a given command

-i,--install		Install an app, if none of the below options are given, check in the following order:
			apt, snap, flatpak, Github manual method, Github automatic method


	-a, ---apt		Install just from apt. In which case, usage will be:

						mrai -ia {apt-package-name}

				To install multiple apps at once, add a comma between each package name:
					
						mrai -ia {package-1},{package-2},{package-3},...

	-g, --git,		Install just from Github, In which case, usage will be:
	--gm, --ga		
						mrai -ig {/github-username/github-repo-name (or Github URL)}
				
					Under this flag you can also use -m or -a to manually indicate whether to install from GitHub manually or
					automaticlly. Please only use the automatic method if the Repo uses a Makefile to install it's software on your
					system.


	-s, --snap		Install just from snapd, In which case, usage will be:

						mrai -is {snap-name}

	
	-f, --flat		Install as Flatpak, In which case, usage will be:

						mrai -if {flatpak-name}


-h, --help		Display this help dialogue and exit.


-r, --remove		Uninstall an app. {name-installed-under} refers to the name given to refer to the GitHub installation,
--uninstall		the name of the apt package, the name of the snap, or the name of the flatpak, depending on how it was installed


-S, --search,		Search for an app. For GitHub based apps, this only works if they are installed. To find apps to install from GitHub,
--query			please vist https://www.github.com

	
	-a, --apt		Search for an app through apt


	-s, --snap		Search for an app through snap


	-f, --flat		Search for an app through flatpak


	--ga			Search for an app that was installed using GitHub Automatic Method


	--gm			Search for an app that was installed using GitHub Manual Method


	--git			Search for an app installed from GitHub, regardless of method


	-v, --verbose		Give more information about the queried package


-u, --update,		Update your software. This may or may not work for packages installed from Github.
--upgrade

	-a, --apt		Update from only apt


	-f, --flat		Update from only Flatpak


	-g, --git		Update from only Github

	
	-s, --snap		Update only installed snaps


-v, --version		Print Current Version and exit


--fix-config		Essentially this runs 'sudo dpkg --configure -a', to fix package management issues


--add-repo		Add a repository, MUST BE FOLLOWED BY ONE OF THE FOLLOWING OPTIONS:


	-a, --apt		adds a new PPA

	
	-f, --flat		adds a new Flatpak Remote


-l, --list		List installed apps, pass a package name after this flag to search for an installed app


	-a, --apt	Filter installed apps to ones installed with apt


	-f, --flat	Filter installed apps to ones installed with Flatpak


	-s, --snap	Filter installed apps to ones installed with Snap


	--ga		Filter installed apps to ones installed using GitHub Automatic Method


	--gm		Filter installed apps to ones installed using GitHub Manual Method


	--git		Filter installed apps to ones installed from GitHub, regardless of method


--edit-sources,		Edit enabled apt repos by editing /etc/apt/sources.list or one of the files
--edit-repos,		in /etc/apt/sources.list.d
--edit-apt-repos,"
if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then
	builtin echo -e "\n$h\n"
	exit 0
fi
#Start Defining Functions

#Force update snaps
snapupdate () {
	{
		/sbin/snapupdate
	} || {
		builtin echo -e "\n$R \bsnapupdate failed with exit code $?.$NC Please fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#Install software from apt
aptinstall () {
	for each in $pass; do
		if $(/usr/bin/dpkg -l "$each" 2>/dev/null | /bin/grep -q "ii  $each"); then
			continue
		else
			if [ -n "$new" ]; then
				new="$new $each"
			else
				new="$each"
			fi
		fi
	done
	for each in $pass; do
		if $(builtin echo "$new" | /bin/grep -q "$each"); then
			verify="$verify 1"
		else
			continue
		fi
	done
	builtin echo "$verify" | /bin/grep -q "1"
	check=$?
	if [ "$check" != "0" ]; then
		builtin echo -e "\n$Y \bAll passed packages are already installed.$NC\n"
		exit 1
	else
			pass="$new"
	fi
	if [ "$check" == "0" ]; then
		if is_aptfast_installed; then
			({
				#Install software using apt-fast, if available based on the apt-fast.flag
				#use /usr/bin/pkexec to gain root privleges in order to install software
				#
				#Because of the way apt works, we have to pass $pass unquoted. Otherwise,
				#apt will read the contents of $pass as a single package name, not a list
				if [ "$a" == "1" ]; then
					/usr/bin/pkexec "/usr/sbin/apt-fast" -y install $pass
				else
					/usr/bin/pkexec "/usr/sbin/apt-fast" install $pass
				fi
			} && {
			#update flags if snapd or flatpak get installed
				if [ "$pass" == "flatpak" ]; then
					builtin echo "" >> "$cache"/flatpak.flag
					/usr/bin/flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
				elif [ "$pass" == "snapd" ]; then
					builtin echo "" >> "$cache"/snapd.flag
				fi
			}) || return 2
		else
			({
				#install software using apt, due to the unavailability of apt-fast
				if [ "$a" == "1" ]; then
					/usr/bin/pkexec "/usr/bin/apt" -y install $pass
				else
					/usr/bin/pkexec "/usr/bin/apt" install $pass
				fi
			} && {
			#update flags if snapd, flatpak, or apt-fast get installed
				if [ "$pass" == "apt-fast" ]; then
					builtin echo "" >> "$cache"/apt-fast.flag
				elif [ "$pass" == "snapd" ]; then
					builtin echo "" >> "$cache"/snapd.flag
				elif [ "$pass" == "flatpak" ]; then
					builtin echo "" >> "$cache"/flatpak.flag
					/usr/bin/flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
				fi
			}) || return 2
		fi
	else
		builtin echo -e "\n$Y \bThis package is already installed.$NC\n"
		if [ "$1" == "-i" ] || [ "$1" == "--install" ]; then
			return 1
		else
			exit 1
		fi
	fi
}

#install software, using a more automatic method, from GitHub
gitautoinst () {
	{
		/usr/bin/pkexec "$scripts/gitautoinst" "$HOME" "$user" "$pass"
	} || {
		builtin echo -e "\n$R \bERROR:$NC gitautoinst has failed with code $?. Please fill out an issue report\non our GitHub at https://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

flatinstall () {
	#check that flatpak.flag is in place
	if is_flatpak_installed; then
		loop=1
		while [ "$loop" == "1" ]; do
			#search for the desired package, to ensure it exists
			package=$(/usr/bin/flatpak search "$pass" | /usr/bin/awk '{print $1}' | /bin/grep -x "$pass")
			if [ "$package" == "No matches found" ] || [ "$package" == "" ] || [ "$package" == " " ]; then
				#see if there are any flatpak repos added, this is a common
				#issue with people new to flatpak. Checking and adding it for them
				#then rechecking just saves them the pain
				list=$(/usr/bin/flatpak remotes)
				if $(builtin echo "$list" | /bin/grep -q 'flathub'); then
					#there are repos added, so the flatpak is at least not in these repos
					#or just straight up does not exist
					builtin echo -e "\n$Y \bNo installation candidates found.$NC\n"
					exit 1
				else
					#no repos where found. Add Flathub and try again.
					/usr/bin/flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
					continue
				fi
			#check to see if it has one of three known flatpack domains. More domains will be added in the future
			elif $(builtin echo "$package" | /bin/grep -q "org.") || $(builtin echo "$package" | /bin/grep -q "com.") || $(builtin echo "$package" | /bin/grep -q "ws.") || $(builtin echo "$package" | /bin/grep -q "net.") ||  $(builtin echo "$package" | /bin/grep -q "io.") ||  $(builtin echo "$package" | /bin/grep -q "work.") || $(builtin echo "$package" | /bin/grep -q "nl.") || $(builtin echo "$package" | /bin/grep -q "im.") || $(builtin echo "$package" | /bin/grep -q "fr.") ||  $(builtin echo "$package" | /bin/grep -q "cc.") ||  $(builtin echo "$package" | /bin/grep -q "info.") ||  $(builtin echo "$package" | /bin/grep -q "in.") ||  $(builtin echo "$package" | /bin/grep -q "eu.") ||  $(builtin echo "$package" | /bin/grep -q "edu.") ||  $(builtin echo "$package" | /bin/grep -q "de.") ||  $(builtin echo "$package" | /bin/grep -q "cx.") ||  $(builtin echo "$package" | /bin/grep -q "us."); then
				test=$(builtin echo "$package" | /usr/bin/awk '{print $2}')
				if [ -z "$test" ] || [ "$test" == "" ] || [ "$test" == " " ]; then	
					#try installing the desired flatpak from each repo
					list=$(/usr/bin/flatpak remotes)
					list1=$(builtin echo "$list" | /usr/bin/awk '{print $1}')
					builtin echo -e "\n$G \bAttempting to install $package as a Flatpak. Please wait . . . $NC\n"
					for entry in $list1; do
						{
							if [ "$a" == "1" ]; then
								/usr/bin/flatpak install -y "$entry" "$package"
							else
								/usr/bin/flatpak install "$entry" "$package"
							fi
							break
						} || { 
							builtin echo -e "\n$R \bFlatpak installation from $entry failed.$NC\n"
						}
					done
					loop="0"
				else
					#for mutliple installation canditdates, ask which the user wishes to install.
					builtin echo -e "\n$Y \bWARNING:$NC Multiple Installation Candidates Detected.\n"
					builtin echo -e "Which package would you like to install?\n$package\n"
					read -rp "Please copy-paste the name of the package here (Type \"exit\", \"break\", or \"end\" to exit): " int
					#check if the user wants out. If they do, let them out
					if [ "$int" == "exit" ] || [ "$int" == "break" ] || [ "$int" == "end" ]; then
						exit 2
					fi
					#go through the install process for the designated flatpak package
					list=$(/usr/bin/flatpak remotes)
					list1=$(builtin echo "$list" | /usr/bin/awk '{print $1}')
					builtin echo -e "\n$G \bAttempting to install $package as a Flatpak. Please wait . . . $NC\n"
					for entry in $list1; do
						{
							if [ "$a" == "1" ]; then
								/usr/bin/flatpak install -y "$entry" "$int"
							else
								/usr/bin/flatpak install "$entry" "$int"
							fi
							break
						} || { 
							builtin echo -e "\n$R \bFlatpak installation from $entry failed.$NC\n"
						}
					done
					loop="0"
				fi
			else
				#Okay. If we end up having to run the code down here, we have an issue. 
				#It's minor, but an issue.
				#This should only run if $r is set to something that EITHER
				#	A. Isn't "No Matches Found"
				#		OR
				#	B. Does not contain the name of a flatpak
				#In fact, lets print that.
				builtin echo -e "\n$R \bERROR:$NC Flatpak returned something other then \"No Matches Found\" or something with the name of at least one Flatpak in it.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
				#There. Bit long, but it was needed. 
				#Alright. Lets end this puppy.
				loop="0"
				return 1
			fi
		done
	else
		#Check to see if they called EXPLICITLY to install using flatpak, cause if they did they may not know they don't have it
		if [ "$1" == "-if" ] || [ "$2" == "--flat" ]; then
			#Tell them they don't have flatpak
			#Also, if the user wants to mrai to use flatpak they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			builtin echo -e "\n$R \bERROR:$NC package 'flatpak' is not installed.$NC Please run {mrai -ia flatpak} to install it.\n"
			error_report "2" "User Error: Flatpak function attempted without flatpak being installed"
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi		
}

#install snap apps
snapinstall () {
	#check for the snapd.flag file
	if is_snapd_installed; then
		#check for the app we want
		for each in $pass; do
			list=$(/usr/bin/snap list)
			if $(builtin echo "$list" | /bin/grep -q "$each"); then
				continue
			else
				new="$new $each"
			fi
		done
		for each in $pass; do
			if $(builtin echo "$new" | /bin/grep -q "$each"); then
				verify="$verify 1"
			else
				continue
			fi
		done
		builtin echo "$verify" | /bin/grep -q "1"
		check=$?
		if [ "$check" != "0" ]; then
			builtin echo -e "\n$Y \bAll passed packages are already installed.$NC\n"
			exit 1
		else
			pass="$new"
		fi
		if [ "$check" == "0" ]; then
			#try to install the snap normally. This is prefered over classic snaps
			#for security reasons due to it's comperably lacking amount of access to the user's system
			#as compared to classic snaps
			/usr/bin/snap install $pass || read -rp "Standard Snap Installation Failed. Attempt Classic Snap Installation? [y/N]: " ans
			if [ -n "$ans" ]; then
				#check to see if they are cool with the classic snaps, and if so install it. Or at least try to.
				if [ "$ans" == "Y" ] || [ "$ans" == "y" ]; then
					/usr/bin/snap install $pass --classic || builtin echo -e "\n$R \bERROR:$NC Snap installation failed.\n"
				else
					return 2
				fi
			fi
		else
			return 1
		fi
	else
		#Check to see if they called EXPLICITLY to install using snapd, cause if they did they may not know they don't have it
		if [ "$z" == "-s" ] || [ "$z" == "--snap" ]; then
			#Tell them they don't have snapd
			#Also, if the user wants to mrai to use snapd they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			builtin echo -e "\nSorry. Package 'snapd' is not installed. Please run {mrai -ia snapd} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi
}

#install from GitHub using manual method
gitmaninstall () {
	cd "$HOME" || return 1
	/bin/mkdir .mrai
	cd .mrai || return 1
	#check the passed URL's syntax
	if $(builtin echo "$pass" | /bin/grep -q 'https://github.com/') || $(builtin echo "$pass" | /bin/grep -q 'http://github.com/'); then
        	git clone "$pass"
	elif $(builtin echo "$pass" | /bin/grep -q 'github.com/'); then
	        git clone https://"$pass"
	else 
	        git clone https://github.com/"$pass"
	fi
	pass1=$(builtin echo "$pass" | /bin/sed 's/.*\///')
	cd "$pass1" || return 1
	builtin echo -e "\n$(/bin/ls)\n"
	#get the file the user needs to run to install their software
	read -rp "Which of the above files would you like to try to run in order to install $z? (Case-Sensitive) : " run
	#check if the indicated file needs to run as root. Cause we can do that . . . indirectly.
	read -rp "Should this file be run with root privleges? [y/N]: " ans
	ans=$(builtin echo "$ans" | /usr/bin/awk '{print tolower($0)}')
	if [ "$ans" == "y" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		/bin/chmod +x "$PWD/$run"
		#run as root
		/usr/bin/pkexec "$PWD/$run"
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		/bin/mkdir "$gitmancache"/"$pass1" && /bin/cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		{
		        builtin echo "ADDRESS=$pass"
		        builtin echo "RUN_AS_ROOT=yes" 
		        builtin echo "RUN=$run"
		} >> "$gitmancache"/man.flag
	elif [ "$ans" == "n" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		/bin/chmod +x "$PWD/$run"
		#run it
		exec "$PWD/$run"
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		/bin/mkdir "$gitmancache"/"$pass1" && /bin/cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		{
		        builtin echo "ADDRESS=$pass"
        		builtin echo "RUN_AS_ROOT=no"
        		builtin echo "RUN=$run"
        	} >> "$gitmancache"/man.flag
	elif [ "$ans" == "cancel" ] || [ "$ans" == "exit" ] || [ "$ans" == "end" ]; then
		builtin echo -e "\n$R \bAborting . . .$NC\n"
	else
		#this will probably happen to someone at some point.
		#WE DO NOT RUN ANYTHING, I REPEAT, ANYTHING, AS ROOT BY DEFAULT
		#THIS PRESENTS A SECURITY RISK AND SHOULD NEVER BE DONE
		builtin echo -e "\n$Y \bInput not recognized. Running without root privileges$NC\n"
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		/bin/chmod +x "$PWD/$run"
		#run it
		exec "$PWD/$run"
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		/bin/mkdir "$gitmancache"/"$pass1" && /bin/cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		{
		        builtin echo "ADDRESS=$pass"
		        builtin echo "RUN_AS_ROOT=null"
		        builtin echo "RUN=$run"
		} >> "$gitmancache"/man.flag
	fi
}

#remove apt packages
aptremove () {
	{
		if [ "$a" == "1" ]; then
			/usr/bin/pkexec "$scripts/aptremove" 1 "$pass" "$user"
		else
			/usr/bin/pkexec "$scripts/aptremove" "$pass" "$user"
		fi
	} || {
		builtin echo -e "\n$R \bERROR:$NC aptremove has failed with exit code $?. Please fill out an issue report at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit $?
	}
}

#remove apps installed through GitHub
gitremove () {
	#check if the passed app is a git-auto app
	if $(gitautolist | /bin/grep -q "$pass"); then
		#cd into the appropriate directory
		cd "$gitautocache"/"$pass" || return 1
		#check for a Makefile
		if $(builtin echo "$(/bin/ls)" | /bin/grep -q "Makefile"); then
			#try make uninstall and make remove, cause they sometimes work
			{
				/usr/bin/make uninstall || /usr/bin/make remove
			} && {
				#something went right, so remove the files that mrai held on to so that it could
				#delete or update the app later
				cd ..
				/bin/rm -rf "$pass"
				builtin echo -e "\n$G \b$pass has been removed.$NC\n"
				exit 0
			}
		else
			builtin echo -e "\n$R \nWe're sorry. No Makefile could be found. Therefore, mrai cannot uninstall $z $NC\n"
		fi
	#check if the passed app is a git-man app if not a git-auto
	elif $(gitmanlist | /bin/grep -q "$pass"); then
		#cd into the proper directory
		cd "$gitmancache"/"$pass" || return 1
		#read the *.flag file and parse the info needed from it
		flag=$(/bin/ls | /bin/grep "man.flag")
		root=$(/bin/cat "$flag" | /bin/grep "RUN_AS_ROOT=")
		run=$(/bin/cat "$flag" | /bin/grep "RUN=")
		run=$(builtin echo "$run" | /bin/sed 's/RUN=//')
		#check if the designated file needs to be run as root
		if [ "$root" == "RUN_AS_ROOT=yes" ]; then
			builtin echo -e "\n$G \bAttempting to uninstall. Please wait . . .$NC\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				builtin echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					builtin echo -e "\n$Y \bAll other options on the install script have failed. Please look online for documentation on how to remove this app.$NC\n"
					exit 2
				fi
				#Sleep so the user can read what we just builtin echoed out
				/bin/sleep 3s
				#run the file with the designated option as root
				( ( /usr/bin/pkexec "$PWD/$run" "$opt" ) && ( sent=1 ) ) || ( ((num+=1)) )
			done
		elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
			builtin echo -e "\n$G \bAttempting to uninstall. Please wait . . .$NC\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				builtin echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					builtin echo -e "\n$Y \bAll other options on the install script have failed. Please look online for documentation on how to remove this app.$NC\n"
					exit 2
				fi
				#Sleep so the user can read what we just builtin echoed out
				/bin/sleep 3s
				#run the file with the designated option, BUT NOT AS ROOT
				( ( exec "$PWD/$run" "$opt" ) && ( sent=1 ) ) || ( ((num+=1)) )
			done
		else
			#Okay, if we get down here, something fucked up.
			#The contents of ANY *.flag file made by one of the two git install functions (see gitmaninstall and gitautoinst)
			#should contain both an "ADDRESS" field and a "RUN_AS_ROOT" feild. RUN_AS_ROOT can only be a "yes", "no", or "null"
			#if RUN_AS_ROOT is set to anything else, this will be displayed
			builtin echo -e "\n$R \bERROR:$NC function gitremove has encountered an error.$NC Please fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
			error_report "2" "Function gitremove ecountered an error"
		fi
	else
		builtin echo -e "\n$R \bERROR:$NC function gitremove has encountered an error.$NC Please fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		error_report "2" "Function gitremove ecountered an error"
	fi		
}

#remove flatpak packages
flatremove () {
	{
		#flatpak doesn't need root, so not called as such
		if [ "$a" == "1" ]; then
			/usr/bin/flatpak remove -y "$pass"
		else
			/usr/bin/flatpak remove "$pass"
		fi
	} || {
		builtin echo -e "\n$R \bERROR:$NC Function flatremove has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#remove snap packages
snapremove () {
	{
		#snap elevates itself to root, so not gonna bother calling it as root. That way, more of it runs without root access,
		#allowing it to be more secure, while also saving space in this file
		/usr/bin/snap remove "$pass"
	} || {
		builtin echo -e "\n$R \bERROR:$NC Function snapremove has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit "$?"
	}
}

#update apps installed through GitHub
gitupdate () {
	#check first to see if gitupdate got passed an empty or null string. Cause why bother if nothing to use?
	if [ "$pass" == " " ] || [ "$pass" == "" ]; then
		builtin echo -e "\n$Y \bNo Apps installed from GitHub through mrai.$NC\n"
		return 0
	fi
	cd "$cache" || return 1
	#do this for each app installed from GitHub
	for each in $pass; do
		pass1="$each"
		if $( /bin/ls | /bin/grep -q "$z"); then
			if $(builtin echo "$pass1" | grep -q "^-"); then
				builtin echo -e "\n$Y \bWARNING:$NC Attempting to enter a directory whose name starts with \"-\""
			fi
			cd "$pass1" || return 1
			#read the *.flag file and parse it for info
			flag=$(/bin/ls | /bin/grep ".flag")
			root=$(/bin/cat "$flag" | /bin/grep "RUN_AS_ROOT=")
			add=$(/bin/cat "$flag" | /bin/grep "ADDRESS=")
			call=$(builtin echo "$add" | /bin/sed 's/ADDRESS=//')
			run=$(/bin/cat "$flag" | /bin/grep "RUN=")
			run=$(builtin echo "$run" | /bin/sed 's/RUN=//')
			back="$PWD"
			del=$(/usr/bin/find . -type f -name "*.deb")
			cd "$HOME"/.mrai/"$pass1" || return 1
			#"Call home" and get the new software
			if $(builtin echo "$call" | /bin/grep -q 'https://github.com/') || $(builtin echo "$call" | /bin/grep -q 'http://github.com/'); then
				git clone "$call"
			elif $(builtin echo "$call" | /bin/grep -q 'github.com/'); then
	        	git clone https://"$call"
			else
				git clone https://github.com/"$call"
			fi
			#check if $run is set, if it isn't, we are using the Makefile method of doing things
			if [[ -z $run ]]; then
				#some Makefiles have an update function. Others you have to reinstall
				( /usr/bin/make update ) || ( /usr/bin/make && /usr/bin/make install ) || builtin echo -e "\n$R \bERROR:$NC Makefile update method failed.\n"
				#clean up
				/bin/rm "$back"/"$del"
				deb=$(/usr/bin/find . -type f -name "*.deb")
				/bin/cp "$deb" "$gitautocache"/"$pass1"
			else
				#check if we need to run this as root
				if [ "$root" == "RUN_AS_ROOT=yes" ]; then
					#run the file as root
					/usr/bin/pkexec "$PWD/$run" "$opt"
				elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
					#run the designated file, but NOT AS ROOT
					exec "$PWD/$run" "$opt"
					#if the *.flag file's RUN_AS_ROOT is set to null, ask if the user wants to reset it to either yes or no
					#none of the *.flag files should have a RUN_AS_ROOT set as null, but it is possible to happen do to the 
					#complexity of programming it to re-ask if the passed string doesn't match a certain set of criteria
					if [ "$root" == "RUN_AS_ROOT=null" ]; then
						#fix the null value
						read -rp "Should this be run as root in the future? [y/N]: " ans
						if [ "$ans" == "y" ] || [ "$ans" == "Y" ]; then
							/bin/sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=yes/g' "$flag"
						elif [ "$ans" == "n" ] || [ "$ans" == "N" ]; then
							/bin/sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=no/g' "$flag"
						else
							builtin echo -e "\n$Y \bAnswer not recognized. We will ask again next time.$NC\n"
						fi
					fi
				fi
			fi
		else
			#gotta have some sorta error handling XD
			builtin echo -e "\n$R \bERROR:$NC app does not appear to be installed from GitHub.\n"
		fi
	done
}

#update flatpaks
flatupdate () {
	#check if the flatpak.flag file is there, cause why use flatpak if flatpak isn't even installed?
	if is_flatpak_installed; then
		#update flatpak packages
		builtin echo -e "\n$G \bUpdating Flatpaks. Please wait . . . $NC\n"
		/usr/bin/flatpak update 2>/dev/null || ( builtin echo -e "\n$R \bFlatpak has had an error. Please try updating again later with 'mrai -uf'.$NC\n"; error_report "1" "Flatpak encountered an error. Updating will continue." )
		builtin echo ""
	elif [ "$1" == "-uf" ] || [ "$2" == "--flat" ]; then
		builtin echo -e "\n$Y \bSorry. Package 'flatpak' is not installed. Please run 'mrai -ia flatpak' to install it.$NC\n"
		exit 2
	fi
}

#figure out how a specific app is installed
checkinstalltype () {
	#check how a given app is installed by checking the list of installed apps in each
	#then /bin/grepping over that list and looking for the app
	type=""
	IFS=","
	for each in $pass; do
		if $(/usr/bin/dpkg -l | /bin/grep -q "ii  $pass"); then
			type=0
		fi
		if is_snapd_installed && $(/usr/bin/snap list | /bin/grep -q "$pass"); then
			type="$type 1"
		fi
		if is_flatpak_installed && $(/usr/bin/flatpak list  | /bin/grep -q "$pass"); then
			type="$type 2"
		fi
		if $(/bin/ls --group-directories-first "$gitautocache" | /bin/grep -q "$pass"); then
			type="$type 3"
		fi
		if $(/bin/ls --group-directories-first "$gitmancache" | /bin/grep -q "$pass"); then
			type="$type 4"
		fi
		if [ "$type" == "" ]; then
			type=5
		fi
	done
	IFS=" "
}

#list apps installed from GitHub that where installed using automatic method
gitautolist () {
	{
		/bin/ls --group-directories-first "$gitautocache"
	} || {
		error="$?"		
		builtin echo -e "\n$R \bERROR:$NC Function gitautolist has failed with exit code $error.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		error_report "$error" "Function gitautolist failed. File system permissions are messed up in $gitautocache"
		exit "$error"
	}
}

#list apps installed from GitHub that where installed using manual method
gitmanlist () {
	{
		/bin/ls --group-directories-first "$gitmancache"
	} || {
		error="$?"
		builtin echo -e "\n$R \bERROR:$NC Function gitmanlist has failed with exit code $error.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		error_report "$error" "Function gitmanlist failed. File system permissions are messed up in $gitmancache"
		exit "$error"
	}
}

#clean up
clean () {
	{
		if [ "$a" == "1" ]; then
			/usr/bin/pkexec "$scripts/clean" -y "$user"
		else
			/usr/bin/pkexec "$scripts/clean" "$user"
		fi
	} || {
		builtin echo -e "\n$R \bERROR:$NC clean has failed with exit code $?. Please fill out an issue report at\nhttps://github.com/drauger-os-development/mrai/issues\n"
		exit 2
	}
}

#Functions to check if suggested packages are installed

#check for snapd
is_snapd_installed () {
	[ -f "$cache"/snapd.flag ];
}

#check for apt-fast
is_aptfast_installed () {
	[ -f "$cache"/apt-fast.flag ];
}
#check for flatpak
is_flatpak_installed () {
	[ -f "$cache"/flatpak.flag ];
}

#report errors
error_report () {
	"$scripts"/log-out "$1" "/sbin/mrai" "$2" "mrai" "$PWD" "$called_as"
	#i know this is kinda the long way to do it but it works reliably so meh?
	if [ "$1" != "1" ] || [ "$1" != "0" ]; then
		exit "$1"
	fi
}

#functions are done. Lets check system configuration:
#check for apt-fast, snapd, and flatpak and update the flags
#here, we continue using the functions cause the functions check for the flags
if $(/usr/bin/dpkg -l | /bin/grep -q "ii  apt-fast"); then
	if is_aptfast_installed; then
		builtin echo "" >/dev/null 2>/dev/null
	else
		/usr/bin/touch "$cache"/apt-fast.flag
	fi
else
	if is_aptfast_installed; then
		/bin/rm "$cache"/apt-fast.flag 2>/dev/null
	fi
fi
if $(/usr/bin/dpkg -l | /bin/grep -q "ii  snapd"); then
	if is_snapd_installed; then
		builtin echo "" >/dev/null 2>/dev/null
	else
		/usr/bin/touch "$cache"/snapd.flag
	fi
else
	if is_snapd_installed; then
		/bin/rm "$cache"/snapd.flag 2>/dev/null
	fi
fi
if $(/usr/bin/dpkg -l | /bin/grep -q "ii  flatpak"); then
	if is_flatpak_installed; then
		builtin echo "" >/dev/null 2>/dev/null
	else
		/usr/bin/touch "$cache"/flatpak.flag
	fi
else
	if is_flatpak_installed; then
		/bin/rm "$cache"/flatpak.flag 2>/dev/null
	fi
fi


z="$3"
#new flag detection system
#set variables so that they can iterated over without throwing errors
u=""
S=""
i=""
r=""
c=""
num="$#"
if [ "$num" == "0" ]; then
	builtin echo -e "\n$R \bERROR:$NC No options passed.\n"
	exit 2
fi
(( num+=1 ))
#search for each main flag type
if $(builtin echo "$1" | grep -q "^--"); then
	#Find flag
	if [ "$1" == "--find" ]; then
		FIND=1
		look="$2"
	#clean flag
	elif [ "$1" == "--clean" ]; then
		c=1
		if [ "$2" == "--assume-yes" ] || [ "$2" == "-y" ]; then
			a=1
		fi
	#uninstall flag
	elif [ "$1" == "--remove" ] || [ "$1" == "--uninstall" ]; then
		r=1
		if [ "$2" == "--assume-yes" ] || [ "$2" == "-y" ]; then
			a=1
		fi
		if [ "$a" != "1" ]; then
			a=0
		fi
		#THIS FLAG WILL NEED $PASS TO WORK
	#upgrade flag
	elif [ "$1" == "--update" ] || [ "$1" == "--upgrade" ]; then
		sent=2
		while (( $(builtin echo "$sent <= $#" | /usr/bin/bc -l) )); do
			if [ "${!sent}" == "--apt" ] || [ "${!sent}" == "-a" ]; then
				u="$u a"
			elif [ "${!sent}" == "--snap" ] || [ "${!sent}" == "-s" ]; then
				u="$u s"
			elif [ "${!sent}" == "--flat" ] || [ "${!sent}" == "-f" ]; then
				u="$u f"
			elif [ "${!sent}" == "--git" ]; then
				u="$u g"
			elif [ "${!sent}" == "--assume-yes" ] || [ "${!sent}" == "-y" ]; then
				a=1
			fi
			(( sent+=1 ))
		done
		if [ "$a" != "1" ]; then
			a=0
		fi
		u=${u:-"a s f g"}
	#List Flag
	elif [ "$1" == "--list" ]; then
		LIST=1
		sent=2
		while [[ "$sent" -le "$#" ]]; do
			if [ "${!sent}" == "--apt" ] || [ "${!sent}" == "-a" ]; then
				L="$L p"
			elif [ "${!sent}" == "--snap" ] || [ "${!sent}" == "-s" ]; then
				L="$L s"
			elif [ "${!sent}" == "--flat" ] || [ "${!sent}" == "-f" ]; then
				L="$L f"
			elif [ "${!sent}" == "--git" ]; then
				L="$L gb"
			elif [ "${!sent}" == "--gm" ]; then
				L="$L gm"
			elif [ "${!sent}" == "--ga" ]; then
				L="$L ga"
			fi
			(( sent+=1 ))
		done
		L=${L:-"a"}
	#Install Flag
	elif [ "$1" == "--install" ]; then
		sent=2
		while (( $(builtin echo "$sent <= $#" | /usr/bin/bc -l) )); do
			if [ "${!sent}" == "--apt" ] || [ "${!sent}" == "-a" ]; then
				i="a"
			elif [ "${!sent}" == "--snap" ] || [ "${!sent}" == "-s" ]; then
				i="s"
			elif [ "${!sent}" == "--flat" ] || [ "${!sent}" == "-f" ]; then
				i="f"
			elif [ "${!sent}" == "--git" ]; then
				i="gb"
			elif [ "${!sent}" == "--gm" ]; then
				i="gm"
			elif [ "${!sent}" == "--ga" ]; then
				i="ga"
			elif [ "${!sent}" == "--assume-yes" ] || [ "{!sent}" == "-y" ]; then
				a=1
			fi
			(( sent+=1 ))
		done
		if [ "$a" != "1" ]; then
			a=0
		fi
		i=${i:-"l"}
	#Search Flag
	elif [ "${!sent}" == "--search" ] || [ "${!sent}" == "--query" ]; then
		sent=2
		while (( $(builtin echo "$sent <= $#" | /usr/bin/bc -l) )); do
			if [ "${!sent}" == "--apt" ] || [ "${!sent}" == "-a" ]; then
				S="$S a"
			elif [ "${!sent}" == "--snap" ] || [ "${!sent}" == "-s" ]; then
				S="$S s"
			elif [ "${!sent}" == "--flat" ] || [ "${!sent}" == "-f" ]; then
				S="$S f"
			elif [ "${!sent}" == "--git" ]; then
				S="$S gb"
			elif [ "${!sent}" == "--gm" ]; then
				S="$S gm"
			elif [ "${!sent}" == "--ga" ]; then
				S="$S ga"
			elif [ "${!sent}" == "--verbose" ]; then
				VERBOSE=1
			fi
			(( sent+=1 ))
		done
		S=${S:-"a"}
	fi
fi
if [ -z "$i" ] && [ -z "$r" ] && [ -z "$c" ] && [ -z "$S" ] && [ -z "$u" ] && [ -z "$LIST" ] && [ -z "$FIND" ]; then
	#compound flag managment system
	while getopts 'uSircl' flag; do
		case "${flag}" in
			#update flag
			u) 
				if [ "$1" == "-u" ] || [ "$1" == "-uy" ] || [ "$1" == "-yu" ]; then
					u="a s f g"
					if [ "$1" == "-uy" ] || [ "$1" == "-yu" ]; then
						a=1
					fi
					break
				fi
				while getopts 'asfgy' flag; do
					case "${flag}" in
						a) u="$u a" ;;
						s) u="$u s" ;;
						f) u="$u f" ;;
						g) u="$u g" ;;
						y) a=1 ;;
						*) 
							if [ "$1" == "-u" ]; then
								u="a s f g"
							else
								builtin echo -e "\n$R \bSorry. This option is not recognized.$NC\n"
								exit 1
							fi
							;;
					esac
				done ;;
			#search flag
			S) 
				if [ "$1" == "-S" ] || [ "$1" == "-Sv" ]; then
					S="a"
					pass="$2"
					if [ "$1" == "-Sv" ]; then
						VERBOSE="1"
					fi
					break
				fi		
				while getopts 'asfgv' flag; do
					case "${flag}" in
						a) S="$S p" ;;
						s) S="$S s" ;;
						f) S="$S f" ;;
						g) 
							if [ "$1" == "-Sg" ]; then
								S="$S l"
								break
							fi
							while getopts 'ma' flag; do
								case "${flag}" in
									m) S="$S m" ;;
									a) S="$S o" ;;
									*) S="$S l" ;;
								esac
							done ;;
						v) VERBOSE="1" ;;
						*) 
							if [ "$1" == "-S" ]; then
								S="a"
							else
								builtin echo -e "\n$R \bSorry. This option is not recognized.$NC\n"
							exit 1
							fi ;;
					esac
				done
				x=2
				while [ "$x" != 1 ]; do
					if [ "$x" == "2" ]; then
						if [ "${!x}" == "" ]; then
							(( x+=1 ))
							continue
						else
							pass="${!x}"
							(( x+=1 ))
							break
						fi
					else
						if [ "${!x}" == "" ]; then
							x=1
							break
						else
							pass="${!x}"
							(( x+=1 ))
							break
						fi
					fi
				done ;;
			#install flag
			i) 
				if [ "$1" == "-i" ] || [ "$1" == "-iy" ] || [ "$1" == "-yi" ]; then
					i="l"
					pass="$2"
					if [ "$1" == "-iy" ] || [ "$1" == "-yi" ]; then
						a=1
					fi
					break
				fi
				while getopts 'asfgy' flag; do
					case "${flag}" in
						a) i="a" ;;
						s) i="s" ;;
						f) i="f" ;;
						y) a=1 ;;
						g) 
							if [ "$1" == "-ig" ]; then
								i="$i gb"
								break
							fi
							while getopts 'ma' flag; do
								case "${flag}" in
									m) i="gm" ;;
									a) i="ga" ;;
									*) i="gb" ;;
								esac
							done ;;
						*) 
							if [ "$1" == "-i" ]; then
								i="l"
							else
								builtin echo -e "\n$R \bSorry. This option is not recognized.$NC\n"
								exit 1
							fi ;;
					esac
				done ;;
			#remove flag
			r) 
				if [ "$1" == "-r" ] || [ "$1" == "-ry" ] || [ "$1" == "-yr" ]; then
					r=1
					if [ "$1" == "-ry" ]; then
						a=1
					fi
				fi;;
			#clean flag
			c)
				if [ "$1" == "-c" ] || [ "$1" == "-cy" ] || [ "$1" == "-yc" ]; then
					c=1
					if [ "$1" == "-cy" ] || [ "$1" == "-yc" ]; then
						a=1
					fi
				fi;;
			l) LIST=1
				while getopts 'asfg' flag; do
					case "${flag}" in
						a) L="$L p" ;;
						s) L="$L s" ;;
						f) L="$L f" ;;
						g) 
							if [ "$1" == "-lg" ]; then
								L="$L gb"
								break
							fi
							while getopts 'ma' flag; do
								case "${flag}" in
									m) L="gm" ;;
									a) L="ga" ;;
									*) L="gb" ;;
								esac
							done ;;
						*) L="p s f gb";;
					esac
				done
				L=${L:-"a"};;
			#all else
			*)
				builtin echo -e "\n$R \bERROR:$NC Option not recognized.$NC\n\n$h\n"
				error_report "2" "User Error: Provided unknown option.";;
		esac
	done
fi
#check to make sure SOMETHING is set
if [ -z "$i" ] && [ -z "$r" ] && [ -z "$c" ] && [ -z "$S" ] && [ -z "$u" ] && [ -z "$LIST" ] && [ -z "$FIND" ]; then
	builtin echo -e "\n$R \bError in main function:$NC Case failed with 0 commands reported. Please file a bug report at https://github.com/drauger-os-development/mrai/issues\n"
	error_report "2" "Verbose and compound flag systems failed. Something was set and got through but was not detected before work segment."
else
	#check for the install flags
	if [[ -n "$i" ]]; then
		#check for apt sub-flag
		if [ "$i" == "a" ]; then
			#set $pass to $y that way aptinstall can use it
			pass="$2"
			pass=$(builtin echo "$pass" | /bin/sed 's/,/ /g')
			aptinstall "$@"
			exit $?
		#git sub-flag
		elif $(builtin echo "$i" | /bin/grep -q "g"); then
			#manual sub-flag
			if $(builtin echo "$i" | /bin/grep -q "gm"); then
				pass="$2"
				( gitmaninstall && exit 0 ) || exit 2
			#auto sub-flag
			elif $(builtin echo "$i" | /bin/grep -q "ga"); then
				pass="$2"
				( gitautoinst && exit 0 ) || exit 2
			elif $(builtin echo "$i" | /bin/grep -q "gb"); then
				pass="$2"
				( gitautoinst && exit 0 ) || ( gitmaninstall && exit 1 ) || exit 2
			fi
		#snap sub-flag
		elif [ "$i" == "s" ]; then
			pass="$2"
			pass=$(builtin echo "$pass" | /bin/sed 's/,/ /g')
			( snapinstall && exit 0 ) || exit 2
		#flatpak sub-flag
		elif [ "$i" == "f" ]; then
			pass="$2"
			( flatinstall && exit 0 ) || exit 2
		#none of the sub-flags where passed, so try ALL install methods until one works
		elif [ "$i" == "l" ]; then
			builtin echo -e "\nAttempting to install\n"	
			{
				aptinstall
			} || {
				snapinstall
			} || {
				flatinstall
			} || {
				pass="$2"
				gitautoinst
			} || {
				gitmaninstall
			} || {
				builtin echo -e "\n$R \bAll installation methods failed.$NC\nPlease make sure that you have the Github username,\nrepo name, and package name spelled correctly\n"
				exit 2
			}
		else
			builtin echo -e "\n$R \bAn error has occured in main function. Please file a bug report at https://github.com/drauger-os-development/mrai/issues$NC\n"
			error_report "2" "Install flag was set but nothing was set dictating what package manager to use."
		fi
	#remove / uninstall flag
	elif [[ -n "$r" ]] && [ "$r" == "1" ]; then
		#check the way a certain app is installed so it can be properly removed
		pass="$2"		
		checkinstalltype
		if $(builtin echo "$type" | /bin/grep -q " "); then
			if [ "$type" == " 1" ]; then
				snapremove
			elif [ "$type" == " 2" ]; then
				flatremove
			elif [ "$type" == " 3" ] || [ "$type" == " 4" ]; then
				gitremove
			else
				#make a case, set a variable containing text equal to methods an app is installed by
				for each in $type; do
					case "$each" in
						0) if [ -z "$show" ]; then show="apt"; else show="$show apt"; fi; input=" 1 for apt"; check="1" ;;
						1) if [ -z "$show" ]; then show="snap"; else show="$show snap"; fi; input="$input 2 for snap"; check="$check 2" ;;
						2) if [ -z "$show" ]; then show="flatpak"; else show="$show flatpak"; fi; input="$input 3 for flatpak"; check="$check 3" ;;
						3) if [ -z "$show" ]; then show="Github_Automatic"; else show="$show Github_Automatic"; fi ;;
						4) if [ -z "$show" ]; then show="Github_Manual"; else show="$show Github_Manual"; fi ;;
						*) 
							builtin echo -e "\n$R \bERROR:$NC unrecognized value in \$type variable. Error in checkinstalltype. Please report bug to https://github.com/drauger-os-development/mrai\n"
							error_report 2 "Unrecognize value in variable \$type in uninstall segment: $type";;
					esac
				done
				if $(builtin echo "$show" | /bin/grep -q "Github"); then
					input="$input 4 for Github Manual OR Automatic"
					check="$check 4"
				fi
				builtin echo -e "\n$G \bThere are mutliple apps which fit the package name passed installer.\n\nThese are installed through: $show\n\nFrom which package manager would you like to uninstall?$NC"
				read -rp "$input. Select ONE: " ans
				while [ -n "$ans" ]; do
					if [ "$ans" == "1" ] && $(builtin echo "$check" | /bin/grep -q "1"); then
						aptremove
						exit 0
					elif [ "$ans" == "2" ] && $(builtin echo "$check" | /bin/grep -q "2"); then
						snapremove
						exit 0
					elif [ "$ans" == "3" ] && $(builtin echo "$check" | /bin/grep -q "3"); then
						flatremove
						exit 0
					elif [ "$ans" == "4" ] && $(builtin echo "$check" | /bin/grep -q "4"); then
						gitremove
						exit 0
					elif [ "$ans" == "exit" ] || [ "$ans" == "cancel" ] || [ "$ans" == "EXIT" ] || [ "$ans" == "CANCEL" ]; then
						builtin echo -e "\n$Y \bExiting . . .$NC\n"
						exit 0
					else
						builtin echo -e "\n$Y \bUnrecognized Input passed. Please try again.$NC\n"
						builtin echo -e "\n$G \bThere are mutliple apps which fit the package name passed installer.\n\nThese are installed through: $show\n\nFrom which package manager would you like to uninstall?$NC"
						read -rp "$input. Select ONE: " ans
					fi
				done
			fi
		elif [ "$type" == "0" ]; then
			aptremove
		elif [ "$type" == "5" ]; then
			builtin echo -e "\n$Y \bAccording to all our databases, this app is not installed.\n\nApps with similar package names:$NC\n\n"
			show=$(/usr/bin/dpkg -l | /bin/grep "$pass")
			builtin echo -e "Apt Packages:\n\n"
			if [ "$show" == " " ] || [ "$show" == "" ]; then
				builtin echo -e "$R \bNo Apt Packages with similar names installed.$NC\n"
			else
				builtin echo -e "$show\n"
			fi
			if is_snapd_installed; then
				show=$(/usr/bin/snap list | /bin/grep "$pass")
				builtin echo -e "Snaps:\n\n"
				if [ "$show" == " " ] || [ "$show" == "" ]; then
					builtin echo -e "$R \bNo Snaps with similar names installed.$NC\n"
				else
					builtin echo -e "$show\n"
				fi
			fi
			if is_flatpak_installed; then
				show=$(/usr/bin/flatpak list | /bin/grep "$pass")
				builtin echo -e "Flatpaks:\n\n"
				if [ "$show" == " " ] || [ "$show" == "" ]; then
					builtin echo -e "$R \bNo Flatpaks with similar names installed.$NC\n"
				else
					builtin echo -e "$show\n"
				fi
			fi
			exit 1
		else
			#if we get something other than a value from 1 and 5 set to $type, we have a SERIOUS issue. Please submit a bug report in this instance
			builtin echo -e "\nmrai has encountered an$R error$NC in function {checkinstalltype}.\nPlease submit a bug report at https://github.com/drauger-os-development/mrai/issues.\n"
			error_report "2" "function checkinstalltype returned an impossible value: $type"
		fi
	#update flag
	elif [[ -n "$u" ]]; then
		for x in $u; do
			if [ "$x" == "f" ]; then
				flatupdate "$@"
			elif [ "$x" == "g" ]; then
				sent=2
				pass=""
				while (( $(builtin echo "$sent <= $#" | /usr/bin/bc -l) )); do
					if $(builtin echo "${!sent}" | grep -q "^-"); then
						(( sent+=1 ))
						continue
					else
						if [ "$pass" == "" ]; then
							pass="${!sent}"
						else
							pass="$pass ${!sent}"
						fi
					fi 
				done
				if [ "$pass" == "" ]; then
					t=$(gitautolist)
					r=$(gitmanlist)
					pass="$t $r"
				fi
				gitupdate
			elif [[ "$x" == "a" ]]; then
				if [ "$a" == "0" ]; then
					{
						if $(builtin echo "$u" | /bin/grep -q "s"); then
							/usr/bin/pkexec "/sbin/aptupdate" -s 2>/dev/null
						else
							/usr/bin/pkexec "/sbin/aptupdate" 2>/dev/null
						fi
					} || {
						error_report "$?" "aptupdate has had an error. Please check error log for more info."
					}
				elif [ "$a" == "1" ]; then
					{
						if $(builtin echo "$u" | /bin/grep -q "s"); then
							/usr/bin/pkexec "/sbin/aptupdate" -sy 2>/dev/null
						else
							/usr/bin/pkexec "/sbin/aptupdate" -y 2>/dev/null
						fi
					} || {
						error_report "$?" "aptupdate has had an error. Please check error log for more info."
					}
				else
					builtin echo -e "\n$R \bAn error has occured in the implementation of the assume-yes flag.$NC\nPlease report this bug to\nhttps://github.com/drauger-os-development/mrai/issues\n"
					error_report "2" "Assume-yes flag \"\$a\" set to non-bool character"
				fi
			elif [[ "$x" == "s" ]]; then
				if $(builtin echo "$u" | /bin/grep -q "a"); then
					continue
				else
					/sbin/snapupdate
				fi
			else
				continue
			fi
		done
	#search flag
	elif [[ -n "$S" ]]; then
		if [ "$VERBOSE" != "1" ]; then
			#apt sub-flag, only search from apt
			if $(builtin echo "$S" | /bin/grep -q "p"); then
				/usr/bin/apt search "$pass"
			fi
			#flatpak sub-flag, only search from flatpak
			if $(builtin echo "$S" | /bin/grep -q "f"); then
				if is_flatpak_installed; then
					/usr/bin/flatpak search "$pass"
				else
					builtin echo -e "\n$Y \bFlatpak is not installed. Please run \"mrai -ia flatpak\" to install it.$NC\n"
				fi
			fi
			#snap sub-flag, only search from snap
			if $(builtin echo "$S" | /bin/grep -q "s"); then
				if is_snapd_installed; then
					/usr/bin/snap search "$pass"
				else
					builtin echo -e "\n$Y \bSnapd is not installed. Please run \"mrai -ia snapd\" to install it.$NC\n"
				fi
			fi
			#Manual GitHub sub-flag, only search apps installed using manual method from GitHub
			if $(builtin echo "$S" | /bin/grep -q "m"); then
				list=$(gitmanlist | /bin/grep "$pass")
				builtin echo -e "\n$G \bInstalled through Manual Method:$NC\n$list\n"
			fi
			#Automatic GitHub sub-flag, only search apps installed using automatic method from GitHub
			if $(builtin echo "$S" | /bin/grep -q "o"); then
				list=$(gitautolist | /bin/grep "$pass")
				builtin echo -e "\n$G \bInstalled through Automatic Method:$NC\n$list\n"
			fi
			#generel GitHub sub-flag, only search apps installed from GitHub, regardless of method
			if $(builtin echo "$S" | /bin/grep -q "l"); then
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				builtin echo -e "\n$G \bInstalled through Manual Method:$NC\n$list1\n\n$G \bInstalled through Automatic Method:$NC\n\n$list2\n\n\n"
			fi
		elif [ "$VERBOSE" == "1" ]; then
			#apt sub-flag, only search from apt
			if $(builtin echo "$S" | /bin/grep -q "p"); then
				/usr/bin/apt show "$pass"
			fi
			#flatpak sub-flag, only search from flatpak
			if $(builtin echo "$S" | /bin/grep -q "f"); then
				if is_flatpak_installed; then
					builtin echo -e "\n$Y \bFlatpak does not support verbose search mode. Using normal search.$NC\n"
					/usr/bin/flatpak search "$pass"
				else
					builtin echo -e "\n$Y \bFlatpak is not installed. Please run \"mrai -ia flatpak\" to install it.$NC\n"
				fi
			fi
			#snap sub-flag, only search from snap
			if $(builtin echo "$S" | /bin/grep -q "s"); then
				if is_snapd_installed; then
					/usr/bin/snap info "$pass"
				else
					builtin echo -e "\n$Y Snapd is not installed. Please run \"mrai -ia snapd\" to install it.$NC\n"
				fi
			fi
			#Manual GitHub sub-flag, only search apps installed using manual method from GitHub
			if $(builtin echo "$S" | /bin/grep -q "m"); then
				builtin echo -e "\n$Y \bGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .$NC\n"
				list=$(gitmanlist | /bin/grep "$pass")
				builtin echo -e "\n$G \bInstalled through Manual Method:$NC\n$list\n"
			fi
			#Automatic GitHub sub-flag, only search apps installed using automatic method from GitHub
			if $(builtin echo "$S" | /bin/grep -q "o"); then
				builtin echo -e "\n$Y \bGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .$NC\n"
				list=$(gitautolist | /bin/grep "$pass")
				builtin echo -e "\n$G \bInstalled through Automatic Method:$NC\n$list\n"
			fi
			#generel GitHub sub-flag, only search apps installed from GitHub, regardless of method
			if $(builtin echo "$S" | /bin/grep -q "l"); then
				builtin echo -e "\n$Y \bGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .$NC\n"
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				builtin echo -e "\n$G \bInstalled through Manual Method:$NC\n$list1\n\n$G \bInstalled through Automatic Method:$NC\n\n$list2\n\n\n"
			fi
		fi
		#search EVERYTHING		
		if [ "$S" == "a" ]; then
			if [ "$VERBOSE" != "1" ]; then
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				builtin echo -e "\n$G \bApt packages:$NC\n"
				/usr/bin/apt search "$pass"
				if is_flatpak_installed; then
					builtin echo -e "\n$G \bFlatpak Packages:$NC\n"
					/usr/bin/flatpak search "$pass"
				fi
				if is_snapd_installed; then
					builtin echo -e "\n$G \bSnap Packages:$NC\n"
					/usr/bin/snap search "$pass"
				fi
				list="$G \bInstalled through Manual Method:$NC
$list1

$G \bInstalled through Automatic Method:$NC

$list2

"
				builtin echo -e "\n$G \bInstalled GitHub Apps:$NC\n"
				if [ "$list1" == " " ] || [ "$list1" == "" ] || [ -z "$list1" ]; then
					if [ "$list2" == " " ] || [ "$list2" == "" ] || [ -z "$list2" ]; then
						builtin echo -e "$Y \bNo matching GitHub Apps Installed.$NC\n"
					else
						builtin echo -e "\n$G \bInstalled through Automatic Method:$NC\n\n$list2\n"
					fi
				elif [ "$list2" == " " ] || [ "$list2" == "" ] || [ -z "$list2" ]; then
					if [ "$list1" == " " ] || [ "$list1" == "" ] || [ -z "$list1" ]; then
						builtin echo -e "$Y \bNo matching GitHub Apps Installed.$NC\n"
					else
						builtin echo -e "\n$G \bInstalled through Manual Method:$NC\n\n$list2\n"
					fi
				else
					builtin echo -e "\n$list\n"
				fi
			elif [ "$VERBOSE" == "1" ]; then
				list1=$(gitmanlist | /bin/grep "$pass")
				list2=$(gitautolist | /bin/grep "$pass")
				builtin echo -e "\n$G \bApt packages:$NC\n"
				/usr/bin/apt show "$pass"
				if is_flatpak_installed; then
					builtin echo -e "\n$G \bFlatpak Packages:$NC\n"
					builtin echo -e "\n$Y \bFlatpak does not support verbose search mode. Using normal search.$NC\n"
					/usr/bin/flatpak search "$pass"
				fi
				if is_snapd_installed; then
					builtin echo -e "\n$G \bSnap Packages:$NC\n"
					/usr/bin/snap info "$pass"
				fi
				builtin echo -e "\n$Y \bGitHub apps do not support Verbose Search mode. Falling Back to Normal Search . . .$NC\n"
				list="$G \bInstalled through Manual Method:$NC
$list1

$G \bInstalled through Automatic Method:$NC

$list2

"
				builtin echo -e "\n$G \bInstalled GitHub Apps:$NC\n"
				if [ "$list" == " " ]; then
					builtin echo -e "$Y \bNo matching GitHub Apps Installed.$NC\n"
				else
					builtin echo "$list"
				fi
			fi
		fi
	#clean flag
	elif [[ -n "$c" ]]; then
		clean
	#List flag
	elif [[ "$LIST" == "1" ]]; then
		if [[ -n "$2" ]]; then
			if $(builtin echo "$L" | /bin/grep -q 'p'); then
				builtin echo -e "\n$G \bApt:$NC\n"
				output=$(/usr/bin/dpkg -l | /bin/grep '^ii')
				if [ -n "$2" ] && [ "$2" != "--apt" ]; then
					builtin echo "$output" | /bin/grep "$2"
				elif [ -n "$3" ]; then
					builtin echo "$output" | /bin/grep "$3"
				else
					builtin echo "$output"
				fi
				builtin echo ""
			fi
			if $(builtin echo "$L" | /bin/grep -q 's'); then
				if is_snapd_installed; then
					builtin echo -e "\n$G \bSnaps:$NC\n"
					/usr/bin/snap list "$2"
					builtin echo ""
				else
					builtin echo -e "\n$Y \bWe're sorry. Snapd is not available. Install it with \"mrai -ia snapd\"$NC\n"
				fi
			fi
			if $(builtin echo "$L" | /bin/grep -q 'f'); then
				if is_flatpak_installed; then
					builtin echo -e "\n$G \bFlatpaks:$NC\n"
					/usr/bin/flatpak list -a | /bin/grep "$2"
					builtin echo ""
				else
					builtin echo -e "\n$Y \bWe're sorry. Flatpak is not available. Install it with \"mrai -ia flatpak\"$NC\n"
				fi
			fi
			if $(builtin echo "$L" | /bin/grep -q 'gm'); then
				list1=$(gitmanlist | /bin/grep "$2")
				builtin echo -e "\n$G \bInstalled GitHub Apps:\nInstalled through Manual Method:$NC\n$list1\n"
			fi
			if $(builtin echo "$L" | /bin/grep -q 'ga'); then
				list2=$(gitautolist | /bin/grep "$2")
				builtin echo -e "\n$G \bInstalled GitHub Apps:\nInstalled through Automatic Method:$NC\n$list2\n"
			fi
			if $(builtin echo "$L" | /bin/grep -q 'gb') && [ ! $(builtin echo "$L" | /bin/grep -q 'ga') ] && [ ! $(builtin echo "$L" | /bin/grep -q 'gm') ]; then
				list1=$(gitmanlist | /bin/grep "$2")
				list2=$(gitautolist | /bin/grep "$2")
				builtin echo -e "\n$G \bInstalled GitHub Apps:\nInstalled through Manual Method:$NC\n$list1\n\n$G \bInstalled through Automatic Method:$NC\n\n$list2\n\n"
			elif $(builtin echo "$L" | /bin/grep -q 'gb'); then
				if $(builtin echo "$L" | /bin/grep -q 'ga') || $(builtin echo "$L" | /bin/grep -q 'gm'); then
					builtin echo -e "\n$Y \bWe're sorry. You already specified either the manual only, or automatic only flags.\nPlease do not use the manual only, automatic only, or unspecified flags in conjunction$NC\n"
				fi
			fi
		else
			builtin echo -e "\n$G \bApt:$NC\n"
			/usr/bin/dpkg -l | /bin/grep '^ii' | /bin/grep "$2"
			if is_snapd_installed; then
				builtin echo -e "\n$G \bSnaps:$NC\n"
				/usr/bin/snap list
			fi
			if is_flatpak_installed; then
				builtin echo -e "\n$G \bFlatpaks:$NC\n"
				/usr/bin/flatpak list -a
			fi
			list1=$(gitmanlist)
			list2=$(gitautolist)
			list="$G \bInstalled through Manual Method:$NC
$list1

$G \bInstalled through Automatic Method:$NC

$list2

"
			builtin echo -e "\n$G \bInstalled GitHub Apps:$NC\n"
			if [ "$list" == "Installed through Manual Method: Installed through Automatic Method:" ]; then
				builtin echo -e "No GitHub Apps Installed.\n"
			else
				builtin echo -e "$list"
			fi
		fi
#Find flag
	elif [ "$FIND" == "1" ]; then
		command_path=$(/usr/bin/dpkg -S $(command -v "$look") 2>/dev/null)
		if [ -z "$command_path" ]; then
			builtin echo -e "\n$R \bERROR:$NC No package providing specificed command.\n"
		else
			command_path=$(builtin echo "$command_path" | /bin/sed 's/:/ /g' | /usr/bin/awk '{print $1}')
			builtin echo -e "\n$G \bPackage Providing Command \"$look\":$NC $command_path\n"
		fi
	#no recognized flags passed
	else
		builtin echo -e "\n$h\n"
	fi
fi
