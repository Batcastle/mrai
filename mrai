#!/bin/bash
# -*- coding: utf-8 -*-
#
#  mrai
#  
#  Copyright 2018 Thomas Castleman <draugeros@gmail.com>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
version="0.4.9-alpha2"
#Start Defining Functions

#Force update snaps
snapupdate () {
	bash /bin/snapupdate
}

#Install software from apt
aptinstall () {
	if $(apt search "$pass" | grep -q "$pass"); then
		if [ -f /etc/mrai/apt-fast.flag ]; then
			({
				#Install software using apt-fast, if available based on the apt-fast.flag
				#use pkexec to gain root privleges in order to install software
				pkexec apt-fast install "$pass" 
			} && {
			#update flags if snapd or flatpak get installed
				if [ "$pass" == "flatpak" ]; then
					echo "" >> /etc/mrai/flatpak.flag
				elif [ "$pass" == "snapd" ]; then
					echo "" >> /etc/mrai/snapd.flag
				fi
			}) || return 2
		else
			({
				#install software using apt, due to the unavailability of apt-fast
				pkexec apt install "$pass"
			} && {
			#update flags if snapd, flatpak, or apt-fast get installed
				if [ "$pass" == "apt-fast" ]; then
					echo "" >> /etc/mrai/apt-fast.flag
				elif [ "$pass" == "snapd" ]; then
					echo "" >> /etc/mrai/snapd.flag
				elif [ "$pass" == "flatpak" ]; then
					echo "" >> /etc/mrai/flatpak.flag
				fi
			}) || return 2
		fi
	else
		return 1
	fi
}

#install software, using a more automatic method, from GitHub
gitautoinst () {
	cd $HOME
	#make directory .mrai if it exists
	if [[ ! -d .mrai ]]; then
		mkdir .mrai
	fi
	cd .mrai
	#check to see how the URL to github is formatted
	#check for a VERY specific location
	if $(echo "$pass" | grep -q 'https://github.com/') || $(echo "$pass" | grep -q 'http://github.com/'); then
	        git clone "$pass"
	#check for a slightly less specific location
	elif $(echo "$pass" | grep -q 'github.com/'); then
	        git clone https://$pass
	#if they did not specifiy "GitHub.com", assume it.
	else 
	        git clone https://github.com/$pass
	fi
	#cd into the new directory git just make from the GitHub repo
	pass1=$(echo $pass | sed 's/.*\///')
	cd $pass1
	#Check for a Makefile
	if $(find Makefile) || $(find makefile); then
		#if a Makefile exists, run make depend to ensure we have all the dependencies we need
		make depend
		#run make && make install to install the new software, if make fails don't bother running make install since
		#it would most likely fail
	        make && make install
		#Back up the Makefile since it might be useful in uninstalling the software
		mkdir "$gitautocache"/"$z" && cp Makefile "$gitautocache"/"$pass1" || cd .. && rm -rf $pass1
		#make a deb as a back up for install/uninstall
		pkexec checkinstall
		#back up the deb to $gitautocache/#pass1
		deb=$(find -type f -name "*.deb")
		cp "$deb" "$gitautocache"/"$pass1"
		echo "ADDRESS=$pass" >> "$gitautocache"/auto.flag
        #copy Makefile to a directory in a good place in the file system. Name the directory it's in the value of $z
	else
	        #remove the folder to save space
		cd ..
	        rm -rf $pass1
	fi
}

flatinstall () {
	#check that flatpak.flag is in place
	if [ -f /etc/mrai/flatpak.flag ]; then
		loop=1
		while [ "$loop" == "1" ]; do
			#search for the desired package, to ensure it exists
			q=$(flatpak search "$pass")
			r=$(echo "$q" | awk '{print $1}')
			if [ "$r" == "No matches found" ]; then
				#see if there are any flatpak repos added, this is a common
				#issue with people new to flatpak. Checking and adding it for them
				#then rechecking just saves them the pain
				list=$(flatpak remotes)
				if $(echo "$list" | grep -q 'flathub'); then
					#there are repos added, so the flatpak is at least not in these repos
					#or just straight up does not exist
					echo -e "\nNo installation candidates found.\n"
					exit 1
				else
					#no repos where found. Add Flathub and try again.
					flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
					continue
				fi
			#check to see if it has one of three known flatpack domains. More domains will be added in the future
			elif $(echo "$r" | grep -q "org.") || $(echo "$r" | grep -q "com.") || $(echo "$r" | grep -q "ws."); then
				set -- "$r"
				test="$2"
				if [ -z "$test" ]; then	
					#try installing the desired flatpak from each repo
					list=$(flatpak remotes)
					list1=$(echo "$list" | awk '{print $1}')
					echo -e "\nAttempting to install $r as a Flatpak. Please wait . . . \n"
					for entry in $list1; do
						{
							flatpak install -y "$entry" "$r"
							break
						} || { 
							echo -e "\nFlatpak installation from $entry failed.\n"
						}
					done
					loop="0"
				else
					#for mutliple installation canditdates, ask which the user wishes to install.
					echo -e "\nERROR: Multiple Installation Candidates Detected.\n"
					echo -e "Which package would you like to install?\n$r\n"
					read -p "Please copy-paste the name of the package here (Type \"exit\", \"break\", or \"end\" to exit): " int
					#check if the user wants out. If they do, let them out
					if [ "$int" == "exit" ] || [ "$int" == "break" ] || [ "$int" == "end" ]; then
						exit 2
					fi
					#go through the install process for the designated flatpak package
					list=$(flatpak remotes)
					list1=$(echo "$list" | awk '{print $1}')
					echo -e "\nAttempting to install $r as a Flatpak. Please wait . . . \n"
					for entry in $list1; do
						{
							flatpak install -y "$entry" "$int"
							break
						} || { 
							echo -e "\nFlatpak installation from $entry failed.\n"
						}
					done
					loop="0"
				fi
			else
				#Okay. If we end up having to run the code down here, we have an issue. 
				#It's minor, but an issue.
				#This should only run if $r is set to something that EITHER
				#	A. Isn't "No Matches Found"
				#		OR
				#	B. Does not contain the name of a flatpak
				#In fact, lets print that.
				echo -e "\nSomething happened...and it wasn't good.\nIt appears Flatpak returned something other then \"No Matches Found\" or something with the name of at least on Flatpak in it.\nPlease report this bug to the devs. Thanks! And sorry for the trouble!\n"
				#There. Bit long, but it was needed. 
				#Alright. Lets end this puppy.
				loop="0"
				exit 1
			fi
		done
	else
		#Check to see if they called EXPLICITLY to install using flatpak, cause if they did they may not know they don't have it
		if [ "$z" == "-f" ] || [ "$z" == "--flat" ]; then
			#Tell them they don't have flatpak
			#Also, if the user wants to mrai to use flatpak they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			echo -e "\nSorry. Package 'flatpak' is not installed. Please run {mrai -i -a flatpak} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi
			
}

#install snap apps
snapinstall () {
	#check for the snapd.flag file
	if [ -f /etc/mrai/snapd.flag ]; then
		#check for the app we want
		if $(snap search "$pass" | grep -q "$pass"); then
			#try to install the snap normally. This is prefered over classic snaps
			#for security reasons due to it's comperably lacking amount of access to the user's system
			#as compared to classic snaps
			snap install "$pass" || read "Standard Snap Installation Failed. Attempt Classic Snap Installation? [y/N]: " ans
			if [ ! -z $ans ]; then
				#check to see if they are cool with the classic snaps, and if so install it. Or at least try to.
				if [ "$ans" == "Y" ] || [ "$ans" == "y" ]; then
					snap install "$pass" --classic || echo -e "\nSnap installation failed.\n"
				else
					return 2
				fi
			fi
		else
			return 1
		fi
	else
		#Check to see if they called EXPLICITLY to install using snapd, cause if they did they may not know they don't have it
		if [ "$z" == "-s" ] || [ "$z" == "--snap" ]; then
			#Tell them they don't have snapd
			#Also, if the user wants to mrai to use snapd they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			echo -e "\nSorry. Package 'snapd' is not installed. Please run {mrai -i -a snapd} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi
}

#install from GitHub using manual method
gitmaninstall () {
	cd $HOME
	mkdir .mrai
	cd .mrai
	#check the passed URL's syntax
	if $(echo "$pass" | grep -q 'https://github.com/') || $(echo "$pass" | grep -q 'http://github.com/'); then
        	git clone "$pass"
	elif $(echo "$pass" | grep -q 'github.com/'); then
	        git clone https://$pass
	else 
	        git clone https://github.com/$pass
	fi
	pass1=$(echo $pass | sed 's/.*\///')
	cd $pass1
	echo -e "\n$(ls)\n"
	#get the file the user needs to run to install their software
	read -p "Which of the above files would you like to try to run in order to install $z? (Case-Sensitive) : " run
	#check if the indicated file needs to run as root. Cause we can do that . . . indirectly.
	read -p "Should this file be run with root privleges? [y/N]: " ans
	ans=$(echo "$ans" | awk '{print tolower($0)}')
	if [ "$ans" == "y" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		chmod +x $(pwd)/$run
		#run as root
		pkexec $(pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		mkdir "$gitmancache"/"$pass1" && cp "$run" "$gitmancache"/"$pass1" || return 2
		#make a backup *.deb file
		pkexec checkinstall
		#copy the new *.deb into the backup directory
		deb=$(find -type f -name "*.deb")
		cp "$deb" "$gitautocache"/"$pass1"
		#write necissary info into the flag, to keep the number of files down
		echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		echo "RUN_AS_ROOT=yes" >> "$gitmancache"/man.flag
		echo "RUN=$run" >> "$gitmancache"/man.flag
	elif [ "$ans" == "n" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		chmod +x $(pwd)/$run
		#run it
		exec $(pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		mkdir "$gitmancache"/"$pass1" && cp "$run" "$gitmancache"/"$pass1" || return 2
		#make a backup *.deb file
		pkexec checkinstall
		#copy the new *.deb into the backup directory
		deb=$(find -type f -name "*.deb")
		cp "$deb" "$gitautocache"/"$pass1"
		#write necissary info into the flag, to keep the number of files down
		echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		echo "RUN_AS_ROOT=no" >> "$gitmancache"/man.flag
		echo "RUN=$run" >> "$gitmancache"/man.flag
	elif [ "$ans" == "cancel" ] || [ "$ans" == "exit" ] || [ "$ans" == "end" ]; then
		echo -e "\nAborting . . .\n"
	else
		#this will probably happen to someone at some point.
		#WE DO NOT RUN ANYTHING, I REPEAT, ANYTHING, AS ROOT BY DEFAULT
		#THIS PRESENTS A SECURITY RISK AND SHOULD NEVER BE DONE
		echo -e "\nInput not recognized. Running without root privileges\n"
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		chmod +x $(pwd)/$run
		#run it
		exec $(pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		mkdir "$gitmancache"/"$pass1" && cp "$run" "$gitmancache"/"$pass1" || return 2
		#make a backup *.deb file
		pkexec checkinstall
		#copy the new *.deb into the backup directory
		deb=$(find -type f -name "*.deb")
		cp "$deb" "$gitautocache"/"$pass1"
		#write necissary info into the flag, to keep the number of files down
		echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		echo "RUN_AS_ROOT=null" >> "$gitmancache"/man.flag
		echo "RUN=$run" >> "$gitmancache"/man.flag
	fi
}

#remove apt packages
aptremove () {
	#remove the software
	pkexec apt purge "$pass"
	#check if the software removed was apt-fast, snapd, or flatpak
	if [ "$pass" == "apt-fast" ]; then
		#remove apt-fast.flag
		rm /etc/mrai/apt-fast.flag
	elif [ "$pass" == "snapd" ]; then
		#remove snapd.flag
		rm /etc/mrai/snapd.flag
	elif [ "$pass" == "flatpak" ]; then
		#remove flatpak.flag
		rm /etc/mrai/flatpak.flag
	fi
}

#remove apps installed through GitHub
gitremove () {
	#check if the passed app is a git-auto app
	if $(gitautolist | grep -q "$pass"); then
		#cd into the appropriate directory
		cd "$gitautocache"/"$pass"
		#check for a Makefile
		if $( echo $(ls) | grep "Makefile"); then
			#try make uninstall and make remove, cause they sometimes work
			(( make uninstall || make remove ) || {
				#check for a *.deb
				if $(find -type f -name "*.deb"); then
					#alright. we found one, so now we need to install and uninstall it
					#that way the files actually get removed
					#lets echo that, just to be safe
					echo -e "\nThe Makefile failed to uninstall this app. We found a deb file we can use to uninstall.\nHowever we must first install it so that the files are registered with apt.\nPlease stand by . . .\n"
					#get the file name
					pak=$(find -type f -name "*.deb")
					#sleep to give the user time to read the echo we just sent out
					sleep 3.5s
					#install then uninstall
					pkexec apt install $(pwd)/"$pak"
					pkexec apt-get purge $(pwd)/"$pak"
				else
					echo -e "\nMakefile uninstall method failed and no *.deb back-up file was found.\nPlease run \n{sudo checkinstall && cp \$(find -type f -name '*.deb') $gitautocache/$z\nThen run\npkexec apt-get location-of-package/package-name" && exit 2
				fi
			}) && {
				#something went right, so remove the files that mrai held on to so that it could
				#delete or update the app later
				cd ..
				rm -rf "$pass"
				echo -e "\n$pass has been removed.\n"
				exit 0
			}
		#check for a *.deb
		elif $(echo $(ls) | grep ".deb"); then
			#get the file name
			pak=$(find -type f -name "*.deb")
			#sleep to give the user time to read the echo we just sent out
			sleep 3.5s
			#install then uninstall
			pkexec apt install $(pwd)/"$pak"
			pkexec apt-get purge $(pwd)/"$pak"
		else
			echo -e "\nWe're sorry. No Makefile or back-up *.deb file could be found. Therefor, mrai cannot uninstall $z\n"
		fi
	#check if the passed app is a git-man app if not a git-auto
	elif $(gitmanlist | grep -q "$pass"); then
		#cd into the proper directory
		cd "$gitmancache"/"$pass"
		#read the *.flag file and parse the info needed from it
		flag=$(ls | grep "man.flag")
		root=$(cat $flag | grep "RUN_AS_ROOT=")
		run=$(cat $flag | grep "RUN=")
		run=$(echo $run | sed 's/RUN=//')
		#check if the designated file needs to be run as root
		if [ "$root" == "RUN_AS_ROOT=yes" ]; then
			echo -e "\nAttempting to uninstall. Please wait . . .\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					echo -e "\nAll other options on the install script have failed. Please look online for documentation on how to remove this app.\nWe are sorry for any inconvenience.\n" && exit 2
				fi
				#Sleep so the user can read what we just echoed out
				sleep 3s
				#run the file with the designated option as root
				(( pkexec $(pwd)/"$run" "$opt" ) && ( sent=1 )) || ( ((num+=1)) )
			done
		elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
			echo -e "\nAttempting to uninstall. Please wait . . .\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					echo -e "\nAll other options on the install script have failed. Please look online for documentation on how to remove this app.\nWe are sorry for any inconvenience.\n" && exit 2
				fi
				#Sleep so the user can read what we just echoed out
				sleep 3s
				#run the file with the designated option, BUT NOT AS ROOT
				(( exec $(pwd)/"$run" "$opt" ) && ( sent=1 )) || ( ((num+=1)) )
			done
		else
			#Okay, if we get down here, something fucked up.
			#The contents of ANY *.flag file made by one of the two git install functions (see gitmaninstall and gitautoinst)
			#should contain both an "ADDRESS" field and a "RUN_AS_ROOT" feild. RUN_AS_ROOT can only be a "yes", "no", or "null"
			#if RUN_AS_ROOT is set to anything else, this will be displayed
			echo -e "\nWe're sorry. The function gitremove in /bin/mrai has encountered an error. Please contact the devs for help.\n" && exit 2
		fi
	else
		echo -e "\nWe're sorry. The function gitremove in /bin/mrai has encountered an error. Please contact the devs for help.\n" && exit 2
	fi
			
			
}

#remove flatpak packages
flatremove () {
	#flatpak doesn't need root, so not called as such
	flatpak remove "$pass"
}

#remove snap packages
snapremove () {
	#snap elevates itself to root, so not gonna bother calling it as root. That way, more of it runs without root access,
	#allowing it to be more secure, while also saving space in this file
	snap remove "$pass"
}

#update apps installed through GitHub
gitupdate () {
	#check first to see if gitupdate got passed an empty or null string. Cause why bother if nothing to use?
	if [ "$pass" == " " ] || [ "$pass" == "" ]; then
		echo -e "\nNo Apps installed from GitHub through mrai.\n"
		return 0
	fi
	cd "$cache"
	#do this for each app installed from GitHub
	for each in "$pass"; do
		pass1="$each"
		if $( ls | grep -q '$z'); then
			cd "$pass1"
			#read the *.flag file and parse it for info
			flag=$(ls | grep ".flag")
			root=$(cat $flag | grep "RUN_AS_ROOT=")
			add=$(cat $flag | grep "ADDRESS=")
			call=$(echo $add | sed 's/ADDRESS=//')
			run=$(cat $flag | grep "RUN=")
			run=$(echo $run | sed 's/RUN=//')
			back=$(pwd)
			del=$(find -type f -name "*.deb")
			cd $HOME/.mrai/"$pass1"
			#"Call home" and get the new software
			if $(echo "$call" | grep -q 'https://github.com/') || $(echo "$call" | grep -q 'http://github.com/'); then
				git clone "$call"
			elif $(echo "$call" | grep -q 'github.com/'); then
	        		git clone https://$call
			else
				git clone https://github.com/$call
			fi
			#check if $run is set, if it isn't, we are using the Makefile method of doing things
			if [[ -z $run ]]; then
				#some Makefiles have an update function. Others you have to reinstall
				( make update ) || ( make && make install ) || echo -e "\nMakefile update method failed.\n"
				#clean up
				rm "$back"/"$del"
				deb=$(find -type f -name "*.deb")
				cp "$deb" "$gitautocache"/"$pass1"
			else
				#check if we need to run this as root
				if [ "$root" == "RUN_AS_ROOT=yes" ]; then
					#run the file as root
					pkexec $(pwd)/$run $opt
					#make a backup *.deb then copy it to the app's archive (or cache. it's both tbh) directory
					pkexec checkinstall
					rm "$back"/"$del"
					deb=$(find -type f -name "*.deb")
					cp "$deb" "$gitautocache"/"$pass1"
				elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
					#run the designated file, but NOT AS ROOT
					exec $(pwd)/$run $opt
					#make a backup *.deb then copy it to the app's archive (or cache. it's both tbh) directory
					pkexec checkinstall
					rm "$back"/"$del"
					deb=$(find -type f -name "*.deb")
					cp "$deb" "$gitautocache"/"$pass1"
					#if the *.flag file's RUN_AS_ROOT is set to null, ask if the user wants to reset it to either yes or no
					#none of the *.flag files should have a RUN_AS_ROOT set as null, but it is possible to happen do to the 
					#complexity of programming it to re-ask if the passed string doesn't match a certain set of criteria
					if [ "$root" == "RUN_AS_ROOT=null" ]; then
						#fix the null value
						read -p "Should this be run as root in the future? [y/N]: " ans
						if [ "$ans" == "y" ] || [ "$ans" == "Y" ]; then
							sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=yes/g' $flag
						elif [ "$ans" == "n" ] || [ "$ans" == "N" ]; then
							sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=no/g' $flag
						else
							echo -e "\nAnswer not recognized. We will ask again next time.\n"
						fi
					fi
				fi
			fi
		else
			#gotta have some sorta error handling XD
			echo -e "\nThis app does not appear to be installed from GitHub.\n"
		fi
	done
}

#update flatpaks
flatupdate () {
	#check if the flatpak.flag file is there, cause why use flatpak if flatpak isn't even installed?
	if [ -f /etc/mrai/flatpak.flag ]; then
		#update flatpak packages
		flatpak update
	fi
}

#figure out how a specific app is installed
checkinstalltype () {
	#check how a given app is installed by checking the list of installed apps in each
	#then grepping over that list and looking for the app
	if $(apt list --installed | grep -q "$pass"); then
		type=0
	elif [ -f /etc/mrai/snapd.flag ] && $(snap list | grep -q "$pass"); then
		type=1
	elif [ -f /etc/mrai/flatpak.flag ] && $(flatpak list  | grep -q "$pass"); then
		type=2
	elif $(ls --group-directories-first "$gitautocache" | grep -q "$pass"); then
		type=3
	elif $(ls --group-directories-first "$gitmancache" | grep -q "$pass"); then
		type=4
	else
		type=5
	fi
}

#list apps installed from GitHub that where installed using automatic method
gitautolist () {
	ls --group-directories-first $gitautocache
}

#list apps installed from GitHub that where installed using manual method
gitmanlist () {
	ls --group-directories-first $gitmancache
}

#Welp. There's all the functions Lets define some variables
h="mrai Package Manager: the Multiple Repo App Installer
Usage:

To Install:
   mrai -i {github-username/github-repo-name (or Github URL)} {possible-apt-package-name (or name to be installed under) }

To Remove:
   mrai -r {name-installed-under}

To Update:
   mrai -u {github-username/github-repo-name (or Github URL)} {possible-apt-package-name (or name installed under) }

To Search:
   mrai -S {package-name}

Options:
-i, --install		Install an app, if none of the below options are given, check in the following order:
				Github automatic,
				apt-get,
				snap,
				flatpak,
				Github manual

	-a, --apt	Install just from apt-get. In which case, usage will be:

				mrai -i -a {apt-package-name}

	-g, --git	Install just from Github, In which case, usage will be:
			
				mrai -i -g {/github-username/github-repo-name (or Github URL)}
				
			Under this flag you can also use -m or -a to manually indicate whether to install from GitHub manually or
			automaticlly. Please only use the automatic method if the Repo uses a Makefile to install it's software on your
			system.

	-s, --snap 	Install just from snapd, In which case, usage will be:

				mrai -i -s {snap-name}
	
	-f, --flat	Install as Flatpak, In which case, usage will be:

				mrai -i -f {flatpak-name}

-h, --help		Display this help dialoge and exit.

-r, --remove,		Uninstall an app. {name-installed-under} refers to the name given to refer to the GitHub installation,
  --uninstall			the name of the apt package, the name of the snap, or the name of the flatpak, depending on how it was installed

-S, --search,		Search for an app. For GitHub based apps, this only works if they are installed. To find apps to install from GitHub,
  --find			please vist https://www.github.com
	
	-a, --apt	Search for an app through apt-get

	-s, --snap	Search for an app through snap

	-f, --flat	Search for an app through flatpak

	--ga		Search for an app that was installed using GitHub Automatic Method

	--gm		Search for an app that was installed using GitHub Manual Method

	--git		Search for an app installed from GitHub, regardless of method

-u, --update		Update your software. This may or may not work for packages installed from Github.

	-a, --apt	Update from only apt-get

	-f, --flat	Update from only Flatpak

	-g, --git	Update from only Github
	
	-s, --snap	Update only installed snaps"
x="$1"
y="$2"
z="$3"
w="$4"
cache="/etc/mrai"
gitautocache="/etc/mrai/gitauto"
gitmancache="/etc/mrai/gitman"
#Great! Variables done. Lets make some code that will run EVERY TIME

#first off, mrai should not be run as root. So, check for that and kill mrai if it is running as root, before it can do any damage
if [[ "$EUID" == "0" ]]; then
    echo -e "\nPlease do not run mrai with root privleges. This will cause file system issues with the GitHub installations.\n" && exit 2
fi
#check if $x is set. if it isn't, print the help dialoge and exit
if [ -z "$x" ]; then
	echo -e "\n$h\n"
	exit 1
else
	#check for the install flags
	if [ "$x" == "-i" ] || [ "$x" == "--install" ]; then
		#check for apt sub-flag
		if [ "$y" == "-a" ] || [ "$y" == "--apt" ]; then
			#set $pass to $z that way aptinstall can use it
			pass="$z"
			( aptinstall && exit 0 ) || exit 2
		#git sub-flag
		elif [ "$y" == "-g" ] || [ "$y" == "--git" ]; then
			#manual sub-flag
			if [ "$z" == "-m" ] || [ "$z" == "--manual" ]; then
				pass="$w"
				( gitmaninstall && exit 0 ) || exit 2
			#auto sub-flag
			elif [ "$z" == "-a" ] || [ "$z" == "--auto" ]; then
				pass="$w"
				( gitautoinst && exit 0 ) || exit 2
			else
				pass="$z"
				( gitautoinst && exit 0 ) || ( gitmaninstall && exit 1 ) || exit 2
			fi
		#snap sub-flag
		elif [ "$y" == "-s" ] || [ "$y" == "--snap" ]; then
			pass="$z"
			( snapinstall && exit 0 || exit 2
		#flatpak sub-flag
		elif [ "$y" == "-f" ] || [ "$y" == "--flat" ]; then
			pass="$z"
			flatinstall && exit 0 || exit 2
		#none of the sub-flags where passed, so try ALL install methods until one works
		else
			echo -e "\nAttempting to install\n"
			pass="$y"	
			{
				aptinstall
			} || {
				snapinstall
			} || {
				flatinstall
			} || {
				pass=$z
				gitautoinst
			} || {
				gitmaninstall
			} || {
				echo -e "\nWe're sorry. All installation methods failed.\nPlease make sure that you have the Github username,\nrepo name, and package name spelled correctly\n"
				exit 2
			}
		fi
	#remove / uninstall flag
	elif [ "$x" == "-r" ] || [ "$x" == "--remove" ] || [ "$x" == "--uninstall" ]; then
		#check the way a certain app is installed so it can be properly removed
		pass="$y"		
		checkinstalltype
		#since $pass is already set to the package name, no need to set it so that the package will be removed
		if [ "$type" == "0" ]; then
			aptremove
		elif [ "$type" == "1" ]; then
			snapremove
		elif [ "$type" == "2" ]; then
			flatremove
		elif [ "$type" == "3" ]; then
			gitautoremove
		elif [ "$type" == "4" ]; then
			gitmanremove
		elif [ "$type" == "5" ]; then
			#error handling
			echo -e "\nAccording to all our databases, this app is not installed.\n"
			exit 1
		else
			#if we get something other than a value from 1 and 5 set to $type, we have a SERIOUS issue. Please submit a bug report in this instance
			echo -e "\nmrai has encountered an error in function {checkinstalltype}.\nPlease contact Thomas Castleman at draugeros@gmail.com to submit a bug report.\n"
			exit 2
		fi
	#update flag
	elif [ "$x" == "-u" ] || [ "$x" == "--update" ]; then
		#apt sub-flag
		if [ "$y" == "-a" ] || [ "$y" == "--apt" ]; then
			pkexec aptupdate
		#flatpak sub-flag
		elif [ "$y" == "-f" ] || [ "$y" == "--flat" ]; then
			flatupdate
		#github sub-flag
		elif [ "$y" == "-g" ] || [ "$y" == "--git" ]; then
			#if $z is set, just update that app
			if [[ ! -z $z ]]; then
				pass="$z"
			#otherwise, update them all
			else
				t=$(gitautolist)
				r=$(gitmanlist)
				pass="$t $r"
			fi
			gitupdate
		#Force update snaps, snap sub-flag
		elif [ "$y" == "-s" ] || [ "$y" == "--snap" ]; then
			snapupdate
		else
			#update all isntalled apps
			#snapupdate does not need to be called. Just pass a -s flag to aptupdate and it will run it itself
			#that way the user's password only has to be asked once
			pkexec aptupdate -s
			flatupdate
			t=$(gitautolist)
			r=$(gitmanlist)
			pass="$t $r"
			gitupdate
		fi
	#help flag
	elif [ "$x" == "-h" ] || [ "$x" == "--help" ]; then
		echo -e "\n$h\n"
		exit 0
	#search flag
	elif [ "$x" == "-S" ] || [ "$x" == "--search" ] || [ "$x" == "--find" ]; then
		#apt sub-flag, only search from apt
		if [ "$y" == "-a" ] || [ "$y" == "--apt" ]; then
			apt search "$z"
		#flatpak sub-flag, only search from flatpak
		elif [ "$y" == "-f" ] || [ "$y" == "--flat" ]; then
			flatpak search "$z"
		#snap sub-flag, only search from snap
		elif [ "$y" == "-s" ] || [ "$y" == "--snap" ]; then
			snap search "$z"
		#Manual GitHub sub-flag, only search apps installed using manual method from GitHub
		elif [ "$y" == "--gm" ]; then
			list=$(gitmanlist | grep "$z")
			echo -e "\n$list\n"
		#Automatic GitHub sub-flag, only search apps installed using automatic method from GitHub
		elif [ "$y" == "--ga" ]; then
			list=$(gitautolist | grep "$z")
			echo -e "\n$list\n"
		#generel GitHub sub-flag, only search apps installed from GitHub, regardless of method
		elif [ "$y" == "--git" ]; then
			list1=$(gitmanlist | grep "$z")
			list2=$(gitautolist | grep "$z")
			list="$list1 $list2"
			echo -e "\n$list\n"
		#search EVERYTHING
		else
			list1=$(gitmanlist | grep "$y")
			list2=$(gitautolist | grep "$y")
			echo -e "\nApt packages:\n"
			apt search "$y"
			if [ -f /etc/mrai/flatpak.flag ]; then
				echo -e "\nFlatpak Packages:\n"
				flatpak search "$y"
			fi
			if [ -f /etc/mrai/snapd.flag ]; then
				echo -e "\nSnap Packages:\n"
				snap search "$y"
			fi
			list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
			echo -e "\nInstalled GitHub Apps:\n"
			if [ "$list" == " " ]; then
				echo -e "No matching GitHub Apps Installed.\n"
			else
				echo "$list"
			fi
		fi
	#version flag
	elif [ "$x" == "--version" ]; then
		echo -e "\n$version\n"
	#no recognized flags passed
	else
		echo -e "\n$h\n"
	fi
fi
