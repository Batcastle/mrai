#!/bin/bash
# -*- coding: utf-8 -*-
#
#  mrai
#  
#  Copyright 2018 Thomas Castleman <draugeros@gmail.com>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#first off, mrai should not be run as root. So, check for that and kill mrai if it is running as root, before it can do any damage
#we want to do this first, in case there are any bugs in the code below
version="0.7.8-alpha4"
if [[ "$EUID" == "0" ]]; then
    echo -e "\nPlease do not run mrai with root privleges. This will cause file system issues with GitHub installations.\n" && exit 2
fi
#pre-config
#check if mrai is already running
pidof -x -o "$$" "mrai" > /dev/null
if [ "$?" == "0" ] && [ "$1" != "--version" ] && [ "$1" != "-v" ]; then
    echo -e "\nmrai is already running.\nFor security and stability reasons, please refrain from using mrai until this process has exited.\n"
	exit 2
fi
cache="/etc/mrai"
gitautocache="/etc/mrai/gitauto"
gitmancache="/etc/mrai/gitman"
user=$(whoami)
if [ "$1" == "--version" ] || [ "$1" == "-v" ]; then
	echo -e "\n$version\n"
	exit 0
elif [ "$1" == "--fix-config" ]; then
	echo -e "\nAttempting to correct package configuration. Please wait . . . \n"
	pkexec dpkg --configure -a
	exit "$?"
elif [ "$1" == "--add-repo" ]; then
	if [ "$2" == "-a" ] || [ "$2" == "--apt" ]; then
		if $(echo "$3" | grep -q "ppa:"); then
			pkexec add-apt-repository "$3"
		else
			pkexec add-apt-repository ppa:"$3"
		fi
	elif [ "$2" == "-f" ] || [ "$2" == "--flat" ]; then
		if $(echo "$3" | grep -q "http://") || $(echo "$3" | grep -q "https://"); then
			read -p "What would you like to name this repo?: " name
			flatpak remote-add --if-not-exists "$name" "$3" && echo "$name" >> "$cache"/flatpak.flag
		else
			read -p "What would you like to name this repo?: " name
			flatpak remote-add --if-not-exists "$name" http://"$3" && echo "$name" >> "$cache"/flatpak.flag
		fi
h="mrai Package Manager: the Multiple Repo App Installer
Usage:

To Install:
   mrai -i {github-username/github-repo-name (or Github URL)} {possible-apt-package-name (or name to be installed under) }

To Remove:
   mrai -r {name-installed-under}

To Update:
   mrai -u {github-username/github-repo-name (or Github URL)} {possible-apt-package-name (or name installed under) }

To Search:
   mrai -S {package-name}

Options:
-c, --clean		Delete old *.deb files, old config files, and old Github files

-i,				Install an app, if none of the below options are given, check in the following order:
--install				Github automatic,
						apt-get,
						snap,
						flatpak,
						Github manual

	-a, ---apt		Install just from apt-get. In which case, usage will be:

						mrai -i -a {apt-package-name}

	-g, --git,		Install just from Github, In which case, usage will be:
	--gm, --ga		
						mrai -i -g {/github-username/github-repo-name (or Github URL)}
				
					Under this flag you can also use -m or -a to manually indicate whether to install from GitHub manually or
					automaticlly. Please only use the automatic method if the Repo uses a Makefile to install it's software on your
					system.

	-s, --snap		Install just from snapd, In which case, usage will be:

						mrai -i -s {snap-name}
	
	-f, --flat		Install as Flatpak, In which case, usage will be:

						mrai -i -f {flatpak-name}

-h, --help		Display this help dialogue and exit.

-r, --remove	Uninstall an app. {name-installed-under} refers to the name given to refer to the GitHub installation,
--uninstall		the name of the apt package, the name of the snap, or the name of the flatpak, depending on how it was installed

-S, --search,	Search for an app. For GitHub based apps, this only works if they are installed. To find apps to install from GitHub,
--query, --find				please vist https://www.github.com
	
	-a, --apt		Search for an app through apt-get

	-s, --snap		Search for an app through snap

	-f, --flat		Search for an app through flatpak

	--ga			Search for an app that was installed using GitHub Automatic Method

	--gm			Search for an app that was installed using GitHub Manual Method

	--git			Search for an app installed from GitHub, regardless of method

-u, --update,	Update your software. This may or may not work for packages installed from Github.
--upgrade
	-a, --apt		Update from only apt-get

	-f, --flat		Update from only Flatpak

	-g, --git		Update from only Github
	
	-s, --snap		Update only installed snaps

-v, --version	Print Current Version and exit

--fix-config	Essentially this runs 'sudo dpkg --configure -a', to fix package management issues

--add-repo		Add a repository, MUST BE FOLLOWED BY ONE OF THE FOLLOWING OPTIONS

	-a, --apt		adds a new PPA
	
	-f, --flat		adds a new Flatpak Remote"
if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then
	echo -e "\n$h\n"
	exit 0
fi
#check for apt-fast, snapd, and flatpak and update the flags
if $(dpkg -l | grep -q "ii  apt-fast"); then
	if [[ ! -f "$cache"/apt-fast.flag ]]; then
		echo "" >> "$cache"/apt-fast.flag
	fi
else
	if [[ -f "$cache"/apt-fast.flag ]]; then
		rm "$cache"/apt-fast.flag
	fi
fi
if $(dpkg -l | grep -q "ii  snapd"); then
	if [[ ! -f "$cache"/snapd.flag ]]; then
		echo "" >> "$cache"/snapd.flag
	fi
else
	if [[ -f "$cache"/snapd.flag ]]; then
		rm "$cache"/snapd.flag
	fi
fi
if $(dpkg -l | grep -q "ii  flatpak"); then
	if [[ ! -f "$cache"/flatpak.flag ]]; then
		echo "" >> "$cache"/flatpak.flag
	fi
else
	if [[ -f "$cache"/flatpak.flag ]]; then
		rm "$cache"/flatpak.flag
	fi
fi
#Start Defining Functions

#Force update snaps
snapupdate () {
	{
		bash /bin/snapupdate
	} || {
		echo -e "\nWe're sorry snapupdate failed with exit code $?. Please fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n"
		exit "$?"
	}
}

#Install software from apt
aptinstall () {
	dpkg -l | grep -q "ii  $pass"
	check=$?
	if [ "$check" != "0" ]; then
		if [ -f /etc/mrai/apt-fast.flag ]; then
			({
				#Install software using apt-fast, if available based on the apt-fast.flag
				#use pkexec to gain root privleges in order to install software
				if [ "$a" == "1" ]; then
					pkexec apt-fast -y install "$pass"
				else
					pkexec apt-fast install "$pass"
				fi
			} && {
			#update flags if snapd or flatpak get installed
				if [ "$pass" == "flatpak" ]; then
					echo "" >> /etc/mrai/flatpak.flag
					flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
				elif [ "$pass" == "snapd" ]; then
					echo "" >> /etc/mrai/snapd.flag
				fi
			}) || return 2
		else
			({
				#install software using apt, due to the unavailability of apt-fast
				if [ "$a" == "1" ]; then
					pkexec apt -y install "$pass"
				else
					pkexec apt install "$pass"
				fi
			} && {
			#update flags if snapd, flatpak, or apt-fast get installed
				if [ "$pass" == "apt-fast" ]; then
					echo "" >> /etc/mrai/apt-fast.flag
				elif [ "$pass" == "snapd" ]; then
					echo "" >> /etc/mrai/snapd.flag
				elif [ "$pass" == "flatpak" ]; then
					echo "" >> /etc/mrai/flatpak.flag
					flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
				fi
			}) || return 2
		fi
	else
		echo -e "\nThis package is already installed.\n"
		if [ "$1" == "-i" ] || [ "$1" == "--install" ]; then
			return 1
		else
			exit 1
		fi
	fi
}

#install software, using a more automatic method, from GitHub
gitautoinst () {
	{
		pkexec /etc/mrai/bin/gitautoinst.sh "$HOME" "$user" "$pass"
	} || {
		echo -e "\nWe're sorry. gitautoinst has failed with code $?. Please fill out an issue report\non our GitHub at https://github.com/Batcastle/mrai/issues\n"
		exit "$?"
	}
}

flatinstall () {
	#check that flatpak.flag is in place
	if [ -f /etc/mrai/flatpak.flag ]; then
		loop=1
		while [ "$loop" == "1" ]; do
			#search for the desired package, to ensure it exists
			q=$(flatpak search "$pass")
			r=$(echo "$q" | awk '{print $1}')
			if [ "$r" == "No matches found" ]; then
				#see if there are any flatpak repos added, this is a common
				#issue with people new to flatpak. Checking and adding it for them
				#then rechecking just saves them the pain
				list=$(flatpak remotes)
				if $(echo "$list" | grep -q 'flathub'); then
					#there are repos added, so the flatpak is at least not in these repos
					#or just straight up does not exist
					echo -e "\nNo installation candidates found.\n"
					exit 1
				else
					#no repos where found. Add Flathub and try again.
					flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
					continue
				fi
			#check to see if it has one of three known flatpack domains. More domains will be added in the future
			elif $(echo "$r" | grep -q "org.") || $(echo "$r" | grep -q "com.") || $(echo "$r" | grep -q "ws.") || $(echo "$r" | grep -q "net.") ||  $(echo "$r" | grep -q "io.") ||  $(echo "$r" | grep -q "work.") || $(echo "$r" | grep -q "nl.") || $(echo "$r" | grep -q "im.") || $(echo "$r" | grep -q "fr.") ||  $(echo "$r" | grep -q "cc.") ||  $(echo "$r" | grep -q "info.") ||  $(echo "$r" | grep -q "in.") ||  $(echo "$r" | grep -q "eu.") ||  $(echo "$r" | grep -q "edu.") ||  $(echo "$r" | grep -q "de.") ||  $(echo "$r" | grep -q "cx.") ||  $(echo "$r" | grep -q "us."); then
				set -- "$r"
				test="$2"
				if [ -z "$test" ]; then	
					#try installing the desired flatpak from each repo
					list=$(flatpak remotes)
					list1=$(echo "$list" | awk '{print $1}')
					echo -e "\nAttempting to install $r as a Flatpak. Please wait . . . \n"
					for entry in $list1; do
						{
							if [ "$a" == "1" ]; then
								flatpak install -y "$entry" "$r"
							else
								flatpak install "$entry" "$r"
							fi
							break
						} || { 
							echo -e "\nFlatpak installation from $entry failed.\n"
						}
					done
					loop="0"
				else
					#for mutliple installation canditdates, ask which the user wishes to install.
					echo -e "\nERROR: Multiple Installation Candidates Detected.\n"
					echo -e "Which package would you like to install?\n$r\n"
					read -p "Please copy-paste the name of the package here (Type \"exit\", \"break\", or \"end\" to exit): " int
					#check if the user wants out. If they do, let them out
					if [ "$int" == "exit" ] || [ "$int" == "break" ] || [ "$int" == "end" ]; then
						exit 2
					fi
					#go through the install process for the designated flatpak package
					list=$(flatpak remotes)
					list1=$(echo "$list" | awk '{print $1}')
					echo -e "\nAttempting to install $r as a Flatpak. Please wait . . . \n"
					for entry in $list1; do
						{
							if [ "$a" == "1" ]; then
								flatpak install -y "$entry" "$int"
							else
								flatpak install "$entry" "$int"
							fi
							break
						} || { 
							echo -e "\nFlatpak installation from $entry failed.\n"
						}
					done
					loop="0"
				fi
			else
				#Okay. If we end up having to run the code down here, we have an issue. 
				#It's minor, but an issue.
				#This should only run if $r is set to something that EITHER
				#	A. Isn't "No Matches Found"
				#		OR
				#	B. Does not contain the name of a flatpak
				#In fact, lets print that.
				echo -e "\nSomething happened...and it wasn't good.\nIt appears Flatpak returned something other then \"No Matches Found\" or something with the name of at least on Flatpak in it.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n"
				#There. Bit long, but it was needed. 
				#Alright. Lets end this puppy.
				loop="0"
				exit 1
			fi
		done
	else
		#Check to see if they called EXPLICITLY to install using flatpak, cause if they did they may not know they don't have it
		if [ "$1" == "-if" ] || [ "$2" == "--flat" ]; then
			#Tell them they don't have flatpak
			#Also, if the user wants to mrai to use flatpak they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			echo -e "\nSorry. Package 'flatpak' is not installed. Please run {mrai -ia flatpak} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi		
}

#install snap apps
snapinstall () {
	#check for the snapd.flag file
	if [ -f /etc/mrai/snapd.flag ]; then
		#check for the app we want
		if $(snap search "$pass" | grep -q "$pass"); then
			#try to install the snap normally. This is prefered over classic snaps
			#for security reasons due to it's comperably lacking amount of access to the user's system
			#as compared to classic snaps
			snap install "$pass" || read "Standard Snap Installation Failed. Attempt Classic Snap Installation? [y/N]: " ans
			if [ ! -z $ans ]; then
				#check to see if they are cool with the classic snaps, and if so install it. Or at least try to.
				if [ "$ans" == "Y" ] || [ "$ans" == "y" ]; then
					snap install "$pass" --classic || echo -e "\nSnap installation failed.\n"
				else
					return 2
				fi
			fi
		else
			return 1
		fi
	else
		#Check to see if they called EXPLICITLY to install using snapd, cause if they did they may not know they don't have it
		if [ "$z" == "-s" ] || [ "$z" == "--snap" ]; then
			#Tell them they don't have snapd
			#Also, if the user wants to mrai to use snapd they have to install it through mrai so 
			#it can make the flag file. Otherwise it won't work.
			echo -e "\nSorry. Package 'snapd' is not installed. Please run {mrai -ia snapd} to install it.\n"
			exit 2
		else
			#they didn't call it so not as big a deal. Lets just return, not exit.
			return 2
		fi
	fi
}

#install from GitHub using manual method
gitmaninstall () {
	cd $HOME
	mkdir .mrai
	cd .mrai
	#check the passed URL's syntax
	if $(echo "$pass" | grep -q 'https://github.com/') || $(echo "$pass" | grep -q 'http://github.com/'); then
        	git clone "$pass"
	elif $(echo "$pass" | grep -q 'github.com/'); then
	        git clone https://$pass
	else 
	        git clone https://github.com/$pass
	fi
	pass1=$(echo $pass | sed 's/.*\///')
	cd $pass1
	echo -e "\n$(ls)\n"
	#get the file the user needs to run to install their software
	read -p "Which of the above files would you like to try to run in order to install $z? (Case-Sensitive) : " run
	#check if the indicated file needs to run as root. Cause we can do that . . . indirectly.
	read -p "Should this file be run with root privleges? [y/N]: " ans
	ans=$(echo "$ans" | awk '{print tolower($0)}')
	if [ "$ans" == "y" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		chmod +x $(pwd)/$run
		#run as root
		pkexec $(pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		mkdir "$gitmancache"/"$pass1" && cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		echo "RUN_AS_ROOT=yes" >> "$gitmancache"/man.flag
		echo "RUN=$run" >> "$gitmancache"/man.flag
	elif [ "$ans" == "n" ]; then
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		chmod +x $(pwd)/$run
		#run it
		exec $(pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		mkdir "$gitmancache"/"$pass1" && cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		echo "RUN_AS_ROOT=no" >> "$gitmancache"/man.flag
		echo "RUN=$run" >> "$gitmancache"/man.flag
	elif [ "$ans" == "cancel" ] || [ "$ans" == "exit" ] || [ "$ans" == "end" ]; then
		echo -e "\nAborting . . .\n"
	else
		#this will probably happen to someone at some point.
		#WE DO NOT RUN ANYTHING, I REPEAT, ANYTHING, AS ROOT BY DEFAULT
		#THIS PRESENTS A SECURITY RISK AND SHOULD NEVER BE DONE
		echo -e "\nInput not recognized. Running without root privileges\n"
		#make the file exicutable, cause even if it doesn't need to be it doesn't hurt
		chmod +x $(pwd)/$run
		#run it
		exec $(pwd)/$run
		#back up files that are typically necissaary for updating or removing the software we just attempted to install
		mkdir "$gitmancache"/"$pass1" && cp "$run" "$gitmancache"/"$pass1" || return 2
		#write necissary info into the flag, to keep the number of files down
		echo "ADDRESS=$pass" >> "$gitmancache"/man.flag
		echo "RUN_AS_ROOT=null" >> "$gitmancache"/man.flag
		echo "RUN=$run" >> "$gitmancache"/man.flag
	fi
}

#remove apt packages
aptremove () {
	#remove the software
	if [ -f /etc/mrai/apt-fast.flag ]; then
		if [ "$a" == "1" ]; then
			pkexec apt-fast -y purge "$pass"
		else
			pkexec apt-fast purge "$pass"
		fi
	else
		if [ "$a" == "1" ]; then
			pkexec apt -y purge "$pass"
		else
			pkexec apt purge "$pass"
		fi
	fi
	#check if the software removed was apt-fast, snapd, or flatpak
	if [ "$pass" == "apt-fast" ]; then
		#remove apt-fast.flag
		rm /etc/mrai/apt-fast.flag
	elif [ "$pass" == "snapd" ]; then
		#remove snapd.flag
		rm /etc/mrai/snapd.flag
	elif [ "$pass" == "flatpak" ]; then
		#remove flatpak.flag
		rm /etc/mrai/flatpak.flag
	fi
}

#remove apps installed through GitHub
gitremove () {
	#check if the passed app is a git-auto app
	if $(gitautolist | grep -q "$pass"); then
		#cd into the appropriate directory
		cd "$gitautocache"/"$pass"
		#check for a Makefile
		if $( echo $(ls) | grep "Makefile"); then
			#try make uninstall and make remove, cause they sometimes work
			{
				make uninstall || make remove
			} && {
				#something went right, so remove the files that mrai held on to so that it could
				#delete or update the app later
				cd ..
				rm -rf "$pass"
				echo -e "\n$pass has been removed.\n"
				exit 0
			}
		else
			echo -e "\nWe're sorry. No Makefile could be found. Therefore, mrai cannot uninstall $z\n"
		fi
	#check if the passed app is a git-man app if not a git-auto
	elif $(gitmanlist | grep -q "$pass"); then
		#cd into the proper directory
		cd "$gitmancache"/"$pass"
		#read the *.flag file and parse the info needed from it
		flag=$(ls | grep "man.flag")
		root=$(cat $flag | grep "RUN_AS_ROOT=")
		run=$(cat $flag | grep "RUN=")
		run=$(echo $run | sed 's/RUN=//')
		#check if the designated file needs to be run as root
		if [ "$root" == "RUN_AS_ROOT=yes" ]; then
			echo -e "\nAttempting to uninstall. Please wait . . .\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					echo -e "\nAll other options on the install script have failed. Please look online for documentation on how to remove this app.\nWe are sorry for any inconvenience.\n" && exit 2
				fi
				#Sleep so the user can read what we just echoed out
				sleep 3s
				#run the file with the designated option as root
				(( pkexec $(pwd)/"$run" "$opt" ) && ( sent=1 )) || ( ((num+=1)) )
			done
		elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
			echo -e "\nAttempting to uninstall. Please wait . . .\n"
			sent=0
			num=1
			#try different commands to the file indicated in the *.flag file
			while [ "$sent" == "0" ]; do
				echo -e "\nTry $num . . .\n"
				if [ "$num" == "1" ]; then
					opt="remove"
				elif [ "$num" == "2" ]; then
					opt="--remove"
				elif [ "$num" == "3" ]; then
					opt="uninstall"
				elif [ "$num" == "4" ]; then
					opt="--uninstall"
				else
					echo -e "\nAll other options on the install script have failed. Please look online for documentation on how to remove this app.\nWe are sorry for any inconvenience.\n" && exit 2
				fi
				#Sleep so the user can read what we just echoed out
				sleep 3s
				#run the file with the designated option, BUT NOT AS ROOT
				(( exec $(pwd)/"$run" "$opt" ) && ( sent=1 )) || ( ((num+=1)) )
			done
		else
			#Okay, if we get down here, something fucked up.
			#The contents of ANY *.flag file made by one of the two git install functions (see gitmaninstall and gitautoinst)
			#should contain both an "ADDRESS" field and a "RUN_AS_ROOT" feild. RUN_AS_ROOT can only be a "yes", "no", or "null"
			#if RUN_AS_ROOT is set to anything else, this will be displayed
			echo -e "\nWe're sorry. The function gitremove has encountered an error. Please fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n" && exit 2
		fi
	else
		echo -e "\nWe're sorry. The function gitremove in /bin/mrai has encountered an error. Please contact the devs for help.\n" && exit 2
	fi		
}

#remove flatpak packages
flatremove () {
	{
		#flatpak doesn't need root, so not called as such
		if [ "$a" == "1" ]; then
			flatpak remove -y "$pass"
		else
			flatpak remove "$pass"
		fi
	} || {
		echo -e "\nWe're sorry. Function flatremove has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n"
		exit "$?"
	}
}

#remove snap packages
snapremove () {
	{
		#snap elevates itself to root, so not gonna bother calling it as root. That way, more of it runs without root access,
		#allowing it to be more secure, while also saving space in this file
		snap remove "$pass"
	} || {
		echo -e "\nWe're sorry. Function snapremove has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n"
		exit "$?"
	}
}

#update apps installed through GitHub
gitupdate () {
	#check first to see if gitupdate got passed an empty or null string. Cause why bother if nothing to use?
	if [ "$pass" == " " ] || [ "$pass" == "" ]; then
		echo -e "\nNo Apps installed from GitHub through mrai.\n"
		return 0
	fi
	cd "$cache"
	#do this for each app installed from GitHub
	for each in $pass; do
		pass1="$each"
		if $( ls | grep -q '$z'); then
			cd "$pass1"
			#read the *.flag file and parse it for info
			flag=$(ls | grep ".flag")
			root=$(cat $flag | grep "RUN_AS_ROOT=")
			add=$(cat $flag | grep "ADDRESS=")
			call=$(echo $add | sed 's/ADDRESS=//')
			run=$(cat $flag | grep "RUN=")
			run=$(echo $run | sed 's/RUN=//')
			back=$(pwd)
			del=$(find -type f -name "*.deb")
			cd $HOME/.mrai/"$pass1"
			#"Call home" and get the new software
			if $(echo "$call" | grep -q 'https://github.com/') || $(echo "$call" | grep -q 'http://github.com/'); then
				git clone "$call"
			elif $(echo "$call" | grep -q 'github.com/'); then
	        		git clone https://$call
			else
				git clone https://github.com/$call
			fi
			#check if $run is set, if it isn't, we are using the Makefile method of doing things
			if [[ -z $run ]]; then
				#some Makefiles have an update function. Others you have to reinstall
				( make update ) || ( make && make install ) || echo -e "\nMakefile update method failed.\n"
				#clean up
				rm "$back"/"$del"
				deb=$(find -type f -name "*.deb")
				cp "$deb" "$gitautocache"/"$pass1"
			else
				#check if we need to run this as root
				if [ "$root" == "RUN_AS_ROOT=yes" ]; then
					#run the file as root
					pkexec $(pwd)/$run $opt
					#make a backup *.deb then copy it to the app's archive (or cache. it's both tbh) directory
					pkexec checkinstall
					rm "$back"/"$del"
					deb=$(find -type f -name "*.deb")
					cp "$deb" "$gitautocache"/"$pass1"
				elif [ "$root" == "RUN_AS_ROOT=no" ] || [ "$root" == "RUN_AS_ROOT=null" ]; then
					#run the designated file, but NOT AS ROOT
					exec $(pwd)/$run $opt
					#if the *.flag file's RUN_AS_ROOT is set to null, ask if the user wants to reset it to either yes or no
					#none of the *.flag files should have a RUN_AS_ROOT set as null, but it is possible to happen do to the 
					#complexity of programming it to re-ask if the passed string doesn't match a certain set of criteria
					if [ "$root" == "RUN_AS_ROOT=null" ]; then
						#fix the null value
						read -p "Should this be run as root in the future? [y/N]: " ans
						if [ "$ans" == "y" ] || [ "$ans" == "Y" ]; then
							sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=yes/g' $flag
						elif [ "$ans" == "n" ] || [ "$ans" == "N" ]; then
							sed -i 's/RUN_AS_ROOT=null/RUN_AS_ROOT=no/g' $flag
						else
							echo -e "\nAnswer not recognized. We will ask again next time.\n"
						fi
					fi
				fi
			fi
		else
			#gotta have some sorta error handling XD
			echo -e "\nThis app does not appear to be installed from GitHub.\n"
		fi
	done
}

#update flatpaks
flatupdate () {
	#check if the flatpak.flag file is there, cause why use flatpak if flatpak isn't even installed?
	if [ -f /etc/mrai/flatpak.flag ]; then
		#update flatpak packages
		flatpak update
	elif [ "$1" == "-uf" ] || [ "$2" == "--flat" ]; then
		echo -e "\nSorry. Package 'flatpak' is not installed. Please run {mrai -ia flatpak} to install it.\n"
		exit 2
	fi
}

#figure out how a specific app is installed
checkinstalltype () {
	#check how a given app is installed by checking the list of installed apps in each
	#then grepping over that list and looking for the app
	if $(dpkg -l | grep -q "ii  $pass"); then
		type=0
	elif [ -f /etc/mrai/snapd.flag ] && $(snap list | grep -q "$pass"); then
		type=1
	elif [ -f /etc/mrai/flatpak.flag ] && $(flatpak list  | grep -q "$pass"); then
		type=2
	elif $(ls --group-directories-first "$gitautocache" | grep -q "$pass"); then
		type=3
	elif $(ls --group-directories-first "$gitmancache" | grep -q "$pass"); then
		type=4
	else
		type=5
	fi
}

#list apps installed from GitHub that where installed using automatic method
gitautolist () {
	{
		ls --group-directories-first $gitautocache
	} || {
		echo -e "\nWe're sorry. Function gitautolist has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n"
		exit "$?"
	}
}

#list apps installed from GitHub that where installed using manual method
gitmanlist () {
	{
		ls --group-directories-first $gitmancache
	} || {
		echo -e "\nWe're sorry. Function gitmanlist has failed with exit code $?.\nPlease fill out an issue report on our GitHub at\nhttps://github.com/Batcastle/mrai/issues\n"
		exit "$?"
	}
}

#clean up
clean () {
	{
		if [ "$a" == "1" ]; then
			pkexec /etc/mrai/bin/clean.sh -y $user
		else
			pkexec /etc/mrai/bin/clean.sh $user
		fi
	} || {
		echo -e "\nWe're sorry. clean.sh has failed with exit code $?. Please fill out an issue report at\nhttps://github.com/Batcastle/mrai/issues\n"
		exit $?
	}
}

#goto function. Cause Windows has it but BASH doesn't \_(*_*)_/
goto () {
    label=$1
    cmd=$(sed -n "/$label:/{:a;n;p;ba};" $0 | grep -v ':$')
    eval "$cmd"
    exit
}

#Welp. There's all the functions Lets define some variables
y="$2"
z="$3"
w="$4"
#new flag detection system
#set variables so that they can iterated over without throwing errors
u=""
S=""
i=""
r=""
c=""
a=0
#install flag
if [ "$1" == "--install" ]; then
	test=2
	while [ "$test" != "1" ]; do
		evaluator=${!test}
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			test=2
			goto start
			exit 0
		fi
		if [ "$evaluator" == "--apt" ]; then
			i="a"
		elif [ "$evaluator" == "--snap" ]; then
			i="s"
		elif [ "$evaluator" == "--flat" ]; then
			i="f"
		elif [ "$evaluator" == "--gm" ]; then
			i="gm"
		elif [ "$evaluator" == "--ga" ]; then
			i="ga"
		elif [ "$evaluator" == "--git" ]; then
			i="gb"
		elif [ "$evaluator" == "-y" ] || [ "$evaluator" == "--assume-yes" ]; then
			a=1
		else
			i=${i:-"l"}
			pass="$evaluator"
		fi
		(( test+=1 ))
	done
#search flag
elif [ "$1" == "--search" ] || [ "$1" == "--find" ] || [ "$1" == "--query" ]; then
	test=2
	while [ "$test" != "1" ]; do
		evaluator=${!test}
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			test=2
			goto start
			exit 0
		fi
		if [ "$evaluator" == "--apt" ]; then
			S="$S p"
		elif [ "$evaluator" == "--snap" ]; then
			S="$S s"
		elif [ "$evaluator" == "--flat" ]; then
			S="$S f"
		elif [ "$evaluator" == "--gm" ]; then
			S="$S m"
		elif [ "$evaluator" == "--ga" ]; then
			S="$S o"
		elif [ "$evaluator" == "--git" ]; then
			S="$S l"
		else
			S=${S:-"a"}
			pass="$evaluator"
		fi
		(( test+=1 ))
	done
#update flag
elif [ "$1" == "--update" ] || [ "$1" == "--upgrade" ]; then
	test=2
	while [ "$test" != "1" ]; do
		evaluator=${!test}
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			goto start
			exit 0
		fi
		if [ "$evaluator" == "--apt" ]; then
			u="$u a"
		elif [ "$evaluator" == "--snap" ]; then
			u="$u s"
		elif [ "$evaluator" == "--flat" ]; then
			u="$u f"
		elif [ "$evaluator" == "--git" ]; then
			u="$u g"
		elif [ "$evaluator" == "-y" ] || [ "$evaluator" == "--assume-yes" ]; then
			a=1
		else
			u=${u:-"a s f g"}
		fi
		(( test+=1 ))
	done
#uninstall flag
elif [ "$1" == "--remove" ] || [ "$1" == "--uninstall" ]; then
	r=1
	pass="$2"
	test=2
	while [ "$test" != "1" ]; do
		evaluator=${!test}
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			goto start
			exit 0
		fi
		if [ "$evaluator" == "--assume-yes" ] || [ "$evaluator" == "-y" ]; then
			a=1
		fi
		(( test+=1 ))
	done
	goto start
	exit 0
#clean flag
elif [ "$1" == "--clean" ]; then
	c=1
	test=2
	while [ "$test" != "1" ]; do
		evaluator=${!test}
		if [ -z $evaluator ] && [ "$test" != "2" ]; then
			goto start
			exit 0
		fi
		if [ "$evaluator" == "--assume-yes" ] || [ "$evaluator" == "-y" ]; then
			a=1
		fi
		(( test+=1 ))
	done
	goto start
	exit 0
fi
#compound flag managment system
while getopts 'uSirc' flag; do
	case "${flag}" in
		#update flag
		u) 
			if [ "$1" == "-u" ] || [ "$1" == "-uy" ] || [ "$1" == "-yu" ]; then
				u="a s f g"
				if [ "$1" == "-uy" ] || [ "$1" == "-yu" ]; then
					a=1
				fi
				break
			fi
			while getopts 'asfgy' flag; do
				case "${flag}" in
					a) u="$u a" ;;
					s) u="$u s" ;;
					f) u="$u f" ;;
					g) u="$u g" ;;
					y) a=1 ;;
					*) 
						if [ "$1" == "-u" ]; then
							u="a s f g"
						else
							echo -e "\nSorry. This option is not recognized.\n"
							exit 1
						fi
						;;
				esac
			done ;;
		#search flag
		S) 
			if [ "$1" == "-S" ]; then
				S="a"
				pass="$2"
				break
			fi			
			while getopts 'asfg' flag; do
				case "${flag}" in
					a) S="$S p" ;;
					s) S="$S s" ;;
					f) S="$S f" ;;
					g) 
						if [ "$1" == "-Sg" ]; then
							S="$S l"
							break
						fi
						while getopts 'ma' flag; do
							case "${flag}" in
								m) S="$S m" ;;
								a) S="$S o" ;;
								*) S="$S l" ;;
							esac
						done ;;
					*) 
						if [ "$1" == "-S" ]; then
							S="a"
						else
							echo -e "\nSorry. This option is not recognized.\n"
							exit 1
						fi ;;
				esac
			done 
			x=2
			while [ "$x" != 1 ]; do
				if [ "$x" == "2" ]; then
					if [ ${!x} == "" ]; then
						(( x+=1 ))
						continue
					else
						pass=${!x}
						(( x+=1 ))
						break
					fi
				else
					if [ ${!x} == "" ]; then
						x=1
						break
					else
						pass=${!x}
						(( x+=1 ))
						break
					fi
				fi
			done ;;
		#install flag
		i) 
			if [ "$1" == "-i" ] || [ "$1" == "-iy" ] || [ "$1" == "-yi" ]; then
				i="l"
				pass="$2"
				if [ "$1" == "-iy" ] || [ "$1" == "-yi" ]; then
					a=1
				fi
				break
			fi
			while getopts 'asfgy' flag; do
				case "${flag}" in
					a) i="a" ;;
					s) i="s" ;;
					f) i="f" ;;
					y) a=1 ;;
					g) 
						if [ "$1" == "-ig" ]; then
							i="$i gb"
							break
						fi
						while getopts 'ma' flag; do
							case "${flag}" in
								m) i="gm" ;;
								a) i="ga" ;;
								*) i="gb" ;;
							esac
						done ;;
					*) 
						if [ "$1" == "-i" ]; then
							i="l"
						else
							echo -e "\nSorry. This option is not recognized.\n"
							exit 1
						fi ;;
				esac
			done ;;
		#remove flag
		r) 
			if [ "$1" == "-r" ] || [ "$1" == "-ry" ] || [ "$1" == "-yr" ]; then
				r=1
				if [ "$1" == "-ry" ]; then
					a=1
				fi
			fi;;
		#clean flag
		c)
			if [ "$1" == "-c" ] || [ "$1" == "-cy" ] || [ "$1" == "-yc"; then
				c=1
				if [ "$1" == "-cy" ] || [ "$1" == "-yc" ]; then
					a=1
				fi
			fi;;
		#all else
		*) echo -e "\nError: Option not recognized.\n\n$h\n"
	esac
done
#start:
#check to make sure SOMETHING is set
if [ -z "$i" ] && [ -z "$r" ] && [ -z "$c" ] && [ -z "$S" ] && [ -z "$u" ]; then
	echo -e "\nError in main function: Case failed with 0 commands reported. Please file a bug report at https://github.com/Batcastle/mrai/issues\n"
	exit 2
else
	#check for the install flags
	if [[ ! -z "$i" ]]; then
		#check for apt sub-flag
		if [ "$i" == "a" ]; then
			#set $pass to $y that way aptinstall can use it
			pass="$y"
			( aptinstall && exit 0 ) || exit 2
		#git sub-flag
		elif $(echo "$i" | grep -q "g"); then
			#manual sub-flag
			if $(echo "$i" | grep -q "gm"); then
				pass="$y"
				( gitmaninstall && exit 0 ) || exit 2
			#auto sub-flag
			elif $(echo "$i" | grep -q "ga"); then
				pass="$y"
				( gitautoinst && exit 0 ) || exit 2
			elif $(echo "$i" | grep -q "gb"); then
				pass="$y"
				( gitautoinst && exit 0 ) || ( gitmaninstall && exit 1 ) || exit 2
			fi
		#snap sub-flag
		elif [ "$i" == "s" ]; then
			pass="$y"
			( snapinstall && exit 0 ) || exit 2
		#flatpak sub-flag
		elif [ "$i" == "f" ]; then
			pass="$y"
			( flatinstall && exit 0 ) || exit 2
		#none of the sub-flags where passed, so try ALL install methods until one works
		elif [ "$i" == "l" ]; then
			echo -e "\nAttempting to install\n"	
			{
				aptinstall
			} || {
				snapinstall
			} || {
				flatinstall
			} || {
				pass="$y"
				gitautoinst
			} || {
				gitmaninstall
			} || {
				echo -e "\nWe're sorry. All installation methods failed.\nPlease make sure that you have the Github username,\nrepo name, and package name spelled correctly\n"
				exit 2
			}
		else
			echo -e "\nAn error has occured in main function. Please file a bug report at https://github.com/Batcastle/mrai/issues\n"
			exit 2
		fi
	#remove / uninstall flag
	elif [[ ! -z "$r" ]] && [ "$r" == "1" ]; then
		#check the way a certain app is installed so it can be properly removed
		pass="$y"		
		checkinstalltype
		#since $pass is already set to the package name, no need to set it so that the package will be removed
		if [ "$type" == "0" ]; then
			aptremove
		elif [ "$type" == "1" ]; then
			snapremove
		elif [ "$type" == "2" ]; then
			flatremove
		elif [ "$type" == "3" ]; then
			gitremove
		elif [ "$type" == "4" ]; then
			gitremove
		elif [ "$type" == "5" ]; then
			#error handling
			echo -e "\nAccording to all our databases, this app is not installed.\n"
			exit 1
		else
			#if we get something other than a value from 1 and 5 set to $type, we have a SERIOUS issue. Please submit a bug report in this instance
			echo -e "\nmrai has encountered an error in function {checkinstalltype}.\nPlease submit a bug report at https://github.com/Batcastle/mrai/issues.\n"
			exit 2
		fi
	#update flag
	elif [[ ! -z "$u" ]]; then
		for x in $u; do
			if [ "$x" == "f" ]; then
				flatupdate
			elif [ "$x" == "g" ]; then
				if [[ ! -z "$2" ]]; then 
					pass="$2"
				else
					t=$(gitautolist)
					r=$(gitmanlist)
					pass="$t $r"
				fi
				gitupdate
			elif [[ "$x" == "a" ]]; then
				if $(echo "$u" | grep -q "s"); then
					pkexec aptupdate -s
				else
					pkexec aptupdate
				fi
			elif [[ "$x" == "s" ]]; then
				if $(echo "$u" | grep -q "a"); then
					continue
				else
					snapupdate
				fi
			else
				continue
			fi
		done
	#search flag
	elif [[ ! -z "$S" ]]; then
		#apt sub-flag, only search from apt
		if $(echo "$S" | grep -q "p"); then
			apt search "$pass"
		fi
		#flatpak sub-flag, only search from flatpak
		if $(echo "$S" | grep -q "f"); then
			if [ -f "$cache"/flatpak.flag ]; then
				flatpak search "$pass"
			else
				echo -e "\nFlatpak is not installed. Please run \"mrai -ia flatpak\" to install it.\n"
			fi
		fi
		#snap sub-flag, only search from snap
		if $(echo "$S" | grep -q "s"); then
			snap search "$pass"
		fi
		#Manual GitHub sub-flag, only search apps installed using manual method from GitHub
		if $(echo "$S" | grep -q "m"); then
			list=$(gitmanlist | grep "$pass")
			echo -e "\nInstalled through Manual Method:\n$list\n"
		fi
		#Automatic GitHub sub-flag, only search apps installed using automatic method from GitHub
		if $(echo "$S" | grep -q "o"); then
			list=$(gitautolist | grep "$pass")
			echo -e "\nInstalled through Automatic Method:\n$list\n"
		fi
		#generel GitHub sub-flag, only search apps installed from GitHub, regardless of method
		if $(echo "$S" | grep -q "l"); then
			list1=$(gitmanlist | grep "$pass")
			list2=$(gitautolist | grep "$pass")
			list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
			echo -e "\n$list\n"
		fi
		#search EVERYTHING
		if [ "$S" == "a" ]; then
			list1=$(gitmanlist | grep "$pass")
			list2=$(gitautolist | grep "$pass")
			echo -e "\nApt packages:\n"
			apt search "$pass"
			if [ -f /etc/mrai/flatpak.flag ]; then
				echo -e "\nFlatpak Packages:\n"
				flatpak search "$pass"
			fi
			if [ -f /etc/mrai/snapd.flag ]; then
				echo -e "\nSnap Packages:\n"
				snap search "$pass"
			fi
			list="Installed through Manual Method:
$list1

Installed through Automatic Method:

$list2

"
			echo -e "\nInstalled GitHub Apps:\n"
			if [ "$list" == " " ]; then
				echo -e "No matching GitHub Apps Installed.\n"
			else
				echo "$list"
			fi
		fi
	#clean flag
	elif [[ ! -z "$c" ]]; then
		clean
	#no recognized flags passed
	else
		echo -e "\n$h\n"
	fi
fi
